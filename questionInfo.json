{"sleepIn": {"id": "p187868", "code": "/* The parameter weekday is true if it is a weekday, and the parameter \n * vacation is true if we are on vacation. We sleep in if it is not a weekday \n * or we're on vacation. Return true if we sleep in.\n */\npublic boolean sleepIn(boolean weekday, boolean vacation) {\n    return !weekday || vacation;\n}\n"}, "monkeyTrouble": {"id": "p181646", "code": "/* We have two monkeys, a and b, and the parameters aSmile and bSmile indicate \n * if each is smiling. We are in trouble if they are both smiling or if \n * neither of them is smiling. Return true if we are in trouble.\n */\npublic boolean monkeyTrouble(boolean aSmile, boolean bSmile) {\n    return aSmile == bSmile;\n}\n"}, "sumDouble": {"id": "p154485", "code": "/* Given two int values, return their sum. Unless the two values are the same, \n * then return double their sum.\n */\npublic int sumDouble(int a, int b) {\n    int sum = a + b;\n    if(a == b)\n        return 2 * sum;\n        \n    return sum;\n}\n"}, "diff21": {"id": "p116624", "code": "/* Given an int n, return the absolute difference between n and 21, except \n * return double the absolute difference if n is over 21.\n */\npublic int diff21(int n) {\n    if(n <= 21)\n        return 21 - n;\n        \n    return 2 * (n - 21);\n}\n"}, "parrotTrouble": {"id": "p140449", "code": "/* We have a loud talking parrot. The \"hour\" parameter is the current hour \n * time in the range 0..23. We are in trouble if the parrot is talking and the \n * hour is before 7 or after 20. Return true if we are in trouble.\n */\npublic boolean parrotTrouble(boolean talking, int hour) {\n    return talking && (hour < 7 || hour > 20);\n}\n"}, "makes10": {"id": "p182873", "code": "/* Given 2 ints, a and b, return true if one if them is 10 or if their sum is \n * 10.\n */\npublic boolean makes10(int a, int b) {\n    return a == 10 || b == 10 || a + b == 10;\n}\n"}, "nearHundred": {"id": "p184004", "code": "/* Given an int n, return true if it is within 10 of 100 or 200. Note: \n * Math.abs(num) computes the absolute value of a number.\n */\npublic boolean nearHundred(int n) {\n    return Math.abs(n - 100) <= 10 || Math.abs(n - 200) <= 10;\n}\n"}, "posNeg": {"id": "p159227", "code": "/* Given 2 int values, return true if one is negative and one is positive. \n * Except if the parameter \"negative\" is true, then return true only if both \n * are negative.\n */\npublic boolean posNeg(int a, int b, boolean negative) {\n    if(negative)\n        return a < 0 && b < 0;\n    else\n        return a * b < 0;\n}\n"}, "notString": {"id": "p191914", "code": "/* Given a string, return a new string where \"not \" has been added to the \n * front. However, if the string already begins with \"not\", return the string \n * unchanged. Note: use .equals() to compare 2 strings.\n */\npublic String notString(String str) {\n    if(str.length() >= 3 && str.substring(0, 3).equals(\"not\"))\n        return str;\n        \n    return \"not \" + str;\n}\n"}, "missingChar": {"id": "p190570", "code": "/* Given a non-empty string and an int n, return a new string where the char \n * at index n has been removed. The value of n will be a valid index of a char \n * in the original string (i.e. n will be in the range 0..str.length()-1 \n * inclusive).\n */\npublic String missingChar(String str, int n) {\n    return str.substring(0,n) + str.substring(n+1);\n}\n"}, "frontBack": {"id": "p123384", "code": "/* Given a string, return a new string where the first and last chars have \n * been exchanged.\n */\npublic String frontBack(String str) {\n    if(str.length() <= 1)\n        return str;\n        \n    char first = str.charAt(0);\n    char last = str.charAt(str.length() - 1);\n                 \n    return last + str.substring(1, str.length()-1) + first;\n}\n"}, "front3": {"id": "p136351", "code": "/* Given a string, we'll say that the front is the first 3 chars of the \n * string. If the string length is less than 3, the front is whatever is \n * there. Return a new string which is 3 copies of the front.\n */\npublic String front3(String str) {\n    String front;\n    if(str.length() < 3)\n        front = str;\n    else\n        front = str.substring(0, 3);\n                   \n    return front + front + front;\n}\n"}, "backAround": {"id": "p161642", "code": "/* Given a string, take the last char and return a new string with the last \n * char added at the front and back, so \"cat\" yields \"tcatt\". The original \n * string will be length 1 or more.\n */\npublic String backAround(String str) {\n    char last = str.charAt(str.length() - 1);\n    return last + str + last;\n}\n"}, "or35": {"id": "p112564", "code": "/* Return true if the given non-negative number is a multiple of 3 or a \n * multiple of 5. Use the % \"mod\" operator.\n */\npublic boolean or35(int n) {\n    return n % 3 == 0 || n % 5 == 0;\n}\n"}, "front22": {"id": "p183592", "code": "/* Given a string, take the first 2 chars and return the string with the 2 \n * chars added at both the front and back, so \"kitten\" yields\"kikittenki\". If \n * the string length is less than 2, use whatever chars are there.\n */\npublic String front22(String str) {\n    String front;\n    if(str.length() < 2)\n        front = str;\n    else\n        front = str.substring(0, 2);\n                  \n    return front + str + front;\n}\n"}, "startHi": {"id": "p191022", "code": "/* Given a string, return true if the string starts with \"hi\" and false \n * otherwise.\n */\npublic boolean startHi(String str) {\n    return str.length() >= 2 && str.substring(0, 2).equals(\"hi\");\n}\n"}, "icyHot": {"id": "p192082", "code": "/* Given two temperatures, return true if one is less than 0 and the other is \n * greater than 100.\n */\npublic boolean icyHot(int temp1, int temp2) {\n    return (temp1 * temp2 < 0) && Math.abs(temp1 - temp2) >= 102;\n}\n"}, "in1020": {"id": "p144535", "code": "/* Given 2 int values, return true if either of them is in the range 10..20 \n * inclusive.\n */\npublic boolean in1020(int a, int b) {\n    return (10 <= a && a <= 20) || (10 <= b && b <= 20);\n}\n"}, "hasTeen": {"id": "p178986", "code": "/* We'll say that a number is \"teen\" if it is in the range 13..19 inclusive. \n * Given 3 int values, return true if 1 or more of them are teen.\n */\npublic boolean hasTeen(int a, int b, int c) {\n    return 13 <= a && a <= 19 ||\n        13 <= b && b <= 19 ||\n        13 <= c && c <= 19;\n}\n"}, "loneTeen": {"id": "p165701", "code": "/* We'll say that a number is \"teen\" if it is in the range 13..19 inclusive. \n * Given 2 int values, return true if one or the other is teen, but not both.\n */\npublic boolean loneTeen(int a, int b) {\n    boolean aTeen = 13 <= a && a <= 19;\n    boolean bTeen = 13 <= b && b <= 19;\n      \n    return aTeen != bTeen;\n}\n"}, "delDel": {"id": "p100905", "code": "/* Given a string, if the string \"del\" appears starting at index 1, return a \n * string where that \"del\" has been deleted. Otherwise, return the string \n * unchanged.\n */\npublic String delDel(String str) {\n    if(str.length() >= 4 && str.substring(1, 4).equals(\"del\"))\n        return str.charAt(0) + str.substring(4);\n           \n    return str;\n}\n"}, "mixStart": {"id": "p151713", "code": "/* Return true if the given string begins with \"mix\", except the 'm' can be \n * anything, so \"pix\", \"9ix\" .. all count.\n */\npublic boolean mixStart(String str) {\n    return str.length() >= 3 && str.substring(1, 3).equals(\"ix\");\n}\n"}, "startOz": {"id": "p199720", "code": "/* Given a string, return a string made of the first 2 chars (if present), \n * however include first char only if it is 'o' and include the second only if \n * it is 'z', so \"ozymandias\" yields \"oz\".\n */\npublic String startOz(String str) {\n    String result = \"\";\n    \n    if(str.length() >= 1 && str.charAt(0) == 'o')\n        result += str.charAt(0);\n        \n    if(str.length() >= 2 && str.charAt(1) == 'z')\n        result += str.charAt(1);\n                        \n    return result;\n}\n"}, "intMax": {"id": "p101887", "code": "/* Given three int values, a b c, return the largest.\n */\npublic int intMax(int a, int b, int c) {\n    int largest = a;\n    \n    if(b > largest)\n        largest = b;\n              \n    if(c > largest)\n        largest = c;\n                        \n    return largest;\n}\n"}, "close10": {"id": "p172021", "code": "/* Given 2 int values, return whichever value is nearest to the value 10, or \n * return 0 in the event of a tie. Note that Math.abs(n) returns the absolute \n * value of a number.\n */\npublic int close10(int a, int b) {\n    int distA = Math.abs(a - 10);\n    int distB = Math.abs(b - 10);\n      \n    if(distA == distB)\n        return 0;\n                \n    return distA < distB ? a : b;\n}\n"}, "in3050": {"id": "p132134", "code": "/* Given 2 int values, return true if they are both in the range 30..40 \n * inclusive, or they are both in the range 40..50 inclusive.\n */\npublic boolean in3050(int a, int b) {\n    boolean aRange1 = 30 <= a && a <= 40;\n    boolean aRange2 = 40 <= a && a <= 50;\n    boolean bRange1 = 30 <= b && b <= 40;\n    boolean bRange2 = 40 <= b && b <= 50;\n          \n    return aRange1 && bRange1 || aRange2 && bRange2;\n}\n"}, "max1020": {"id": "p177372", "code": "/* Given 2 positive int values, return the larger value that is in the range \n * 10..20 inclusive, or return 0 if neither is in that range.\n */\npublic int max1020(int a, int b) {\n    if(b > a) {\n        a = a + b;\n        b = a - b;\n        a = a - b;\n    }\n                  \n    if(10 <= a && a <= 20)\n        return a;\n                            \n    if(10 <= b && b <= 20)\n        return b;\n                                      \n    return 0;\n}\n"}, "stringE": {"id": "p173784", "code": "/* Return true if the given string contains between 1 and 3 'e' chars.\n */\npublic boolean stringE(String str) {\n    int num = 0;\n    for(int i = 0; i < str.length(); i++) {\n        if(str.charAt(i) == 'e')\n            num++;\n    }\n    return 1 <= num && num <= 3;\n}\n"}, "lastDigit": {"id": "p169213", "code": "/* Given three ints, a b c, return true if two or more of them have the same \n * rightmost digit. The ints are non-negative.\n */\npublic boolean lastDigit(int a, int b, int c) {\n    return (a % 10 == b % 10) || (a % 10 == c % 10) || (b % 10 == c % 10);\n}\n"}, "endUp": {"id": "p125268", "code": "/* Given a string, return a new string where the last 3 chars are now in \n * upper case. If the string has less than 3 chars, uppercase whatever is \n * there. Note that str.toUpperCase() returns the uppercase version of a \n * string.\n */\npublic String endUp(String str) {\n    if(str.length() < 3)\n        return str.toUpperCase();\n          \n    return str.substring(0, str.length() - 3) + \n        str.substring(str.length() - 3).toUpperCase();\n}\n"}, "everyNth": {"id": "p196441", "code": "/* Given a non-empty string and an int N, return the string made starting \n * with char 0, and then every Nth char of the string. So if N is 3, use \n * char 0, 3, 6, ... and so on. N is 1 or more.\n */\npublic String everyNth(String str, int n) {\n    int nSize = (int) Math.ceil((double) str.length() / n);\n    char[] nchar = new char[nSize];\n    int index = 0;\n        \n    for(int i = 0; i < str.length(); i += n) {\n        nchar[index] = str.charAt(i);\n        index++;\n    }\n                      \n    return new String(nchar);\n}\n"}, "stringTimes": {"id": "p142270", "code": "/* Given a string and a non-negative int n, return a larger string that is n \n * copies of the original string.\n */\npublic String stringTimes(String str, int n) {\n    char[] nCopy = new char[n * str.length()];\n    int index = 0;\n    \n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < str.length(); j++) {\n            nCopy[index] = str.charAt(j);\n            index++;\n        }\n    }\n                                \n    return new String(nCopy);\n}\n"}, "frontTimes": {"id": "p101475", "code": "/* Given a string and a non-negative int n, we'll say that the front of the \n * string is the first 3 chars, or whatever is there if the string is less \n * than length 3. Return n copies of the front.\n */\npublic String frontTimes(String str, int n) {\n    char[] result;\n    String front;\n      \n    if(str.length() < 3)\n        front = str;\n    else\n        front = str.substring(0, 3);\n                      \n    result = new char[n * front.length()];\n                          \n    int index = 0;\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < front.length(); j++) {\n            result[index] = front.charAt(j);\n            index++;\n        }\n    }\n                                                        \n    return new String(result);\n}\n"}, "countXX": {"id": "p194667", "code": "/* Count the number of \"xx\" in the given string. We'll say that overlapping is \n * allowed, so \"xxx\" contains 2 \"xx\".\n */\nint countXX(String str) {\n    int count = 0;\n    for(int i = 0; i < str.length() - 1; i++) {\n        if(str.substring(i, i + 2).equals(\"xx\"))\n            count++;\n    }\n    return count;\n}\n"}, "doubleX": {"id": "p186759", "code": "/* Given a string, return true if the first instance of \"x\" in the string is \n * immediately followed by another \"x\".\n */\nboolean doubleX(String str) {\n    for(int i = 0; i < str.length() - 1; i++) {\n        if(str.charAt(i) == 'x') {\n            if(str.charAt(i + 1) == 'x')\n                return true;\n            else\n                return false;\n        }\n    }\n    return false;\n}\n"}, "stringBits": {"id": "p165666", "code": "/* Given a string, return a new string made of every other char starting with \n * the first, so \"Hello\" yields \"Hlo\".\n */\npublic String stringBits(String str) {\n    int size = (int) Math.ceil((double) str.length() / 2);\n    char[] result = new char[size];\n      \n    int index = 0;\n    for(int i = 0; i < str.length(); i += 2) {\n        result[index] = str.charAt(i);\n        index++;\n    }\n                      \n    return new String(result);\n}\n"}, "stringSplosion": {"id": "p117334", "code": "/* Given a non-empty string like \"Code\" return a string like \"CCoCodCode\".\n */\npublic String stringSplosion(String str) {\n    int size = (str.length() * (str.length() + 1)) / 2;\n    char[] result = new char[size];\n      \n    int index = 0;\n    for(int i = 0; i < str.length(); i++) {\n        for(int j = 0; j <= i; j++) {\n            result[index] = str.charAt(j);\n            index++;\n        }\n    }\n                                  \n    return new String(result);\n}\n"}, "last2": {"id": "p178318", "code": "/* Given a string, return the count of the number of times that a substring \n * length 2 appears in the string and also as the last 2 chars of the string, \n * so \"hixxxhi\" yields 1 (we won't count the end substring).\n */\npublic int last2(String str) {\n    if(str.length() < 2)\n        return 0;\n          \n    String end = str.substring(str.length() - 2);\n    int count = 0;\n                \n    for(int i = 0; i < str.length() - 2; i++) {\n        if(str.substring(i, i + 2).equals(end))\n            count++;\n    }\n                                \n    return count;\n}\n"}, "arrayCount9": {"id": "p184031", "code": "/* Given an array of ints, return the number of 9's in the array.\n */\npublic int arrayCount9(int[] nums) {\n    int count = 0;\n    \n    for(int i = 0; i < nums.length; i++) {\n        if(nums[i] == 9)\n            count++;\n    }\n                    \n    return count;\n}\n"}, "arrayFront9": {"id": "p186031", "code": "/* Given an array of ints, return true if one of the first 4 elements in the \n * array is a 9. The array length may be less than 4.\n */\npublic boolean arrayFront9(int[] nums) {\n    int i = 0;\n    \n    while(i < nums.length && i < 4) {\n        if(nums[i] == 9)\n            return true;\n                      \n        i++;\n    }\n                              \n    return false;\n}\n"}, "array123": {"id": "p136041", "code": "/* Given an array of ints, return true if .. 1, 2, 3, .. appears in the array \n * somewhere.\n */\npublic boolean array123(int[] nums) {\n    for(int i = 0; i < nums.length - 2; i++) {\n        if(nums[i] == 1 && nums[i+1] == 2 && nums[i+2] == 3)\n            return true;\n    }\n    \n    return false;\n}\n"}, "stringMatch": {"id": "p198640", "code": "/* Given 2 strings, a and b, return the number of the positions where they \n * contain the same length 2 substring. So \"xxcaazz\" and \"xxbaaz\" yields 3, \n * since the \"xx\", \"aa\", and \"az\" substrings appear in the same place in both \n * strings.\n */\npublic int stringMatch(String a, String b) {\n    int min = Math.min(a.length(), b.length());\n    int count = 0;\n      \n    for(int i = 0; i < min - 1; i++) {\n        if(a.substring(i, i + 2).equals(b.substring(i, i + 2)))\n            count++;\n    }\n                      \n    return count;\n}\n"}, "stringX": {"id": "p171260", "code": "/* Given a string, return a version where all the \"x\" have been removed. \n * Except an \"x\" at the very start or end should not be removed.\n */\npublic String stringX(String str) {\n    if(str.length() < 2)\n        return str;\n          \n    char[] result = new char[str.length()];\n    result[0] = str.charAt(0);\n                \n    int count = 1;\n    for(int i = 1; i < str.length() - 1; i++) {\n        if(str.charAt(i) != 'x') {\n            result[count] = str.charAt(i);\n            count++;\n        }\n    }\n                                            \n    result[count] = str.charAt(str.length() - 1);\n    count++;\n    return new String(result, 0, count);\n}\n"}, "altPairs": {"id": "p121596", "code": "/* Given a string, return a string made of the chars at indexes \n * 0,1, 4,5, 8,9 ... so \"kittens\" yields \"kien\".\n */\npublic String altPairs(String str) {\n    char[] result = new char[str.length()];\n    int count = 0;\n      \n    int i = 0;\n    int inc = 1;\n    while(i < str.length()) {\n        result[count] = str.charAt(i);\n        count++;\n        i += inc;\n                            \n        if(inc == 1)\n            inc = 3;\n        else\n            inc = 1;\n    }\n                                                    \n    return new String(result, 0, count);\n}\n"}, "stringYak": {"id": "p126212", "code": "/* Suppose the string \"yak\" is unlucky. Given a string, return a version where \n * all the \"yak\" are removed, but the \"a\" can be any char. The \"yak\" strings \n * will not overlap.\n */\npublic String stringYak(String str) {\n    char[] result = new char[str.length()];\n    int count = 0;\n\n    for(int i = 0; i < str.length();) {\n        if(i < str.length() - 2 && str.charAt(i) == 'y' && \n            str.charAt(i + 2) == 'k') {\n            i += 3;\n        } else {\n            result[count] = str.charAt(i);\n            count++;\n            i++;\n        }\n    } \n                                                     \n    return new String(result, 0, count);\n}\n"}, "array667": {"id": "p110019", "code": "/* Given an array of ints, return the number of times that two 6's are next to \n * each other in the array. Also count instances where the second \"6\" is \n * actually a 7.\n */\npublic int array667(int[] nums) {\n    int count = 0;\n    \n    for(int i = 0; i < nums.length - 1; i++) {\n        if(nums[i] == 6 && (nums[i+1] == 6 || nums[i+1] == 7))\n            count++;\n    }\n                    \n    return count;\n}\n"}, "noTriples": {"id": "p170221", "code": "/* Given an array of ints, we'll say that a triple is a value appearing 3 \n * times in a row in the array. Return true if the array does not contain any \n * triples.\n */\npublic boolean noTriples(int[] nums) {\n    for(int i = 0; i < nums.length - 2; i++) {\n        if(nums[i+1] == nums[i] && nums[i+2] == nums[i])\n            return false;\n    }\n                \n    return true;\n}\n"}, "has271": {"id": "p167430", "code": "/* Given an array of ints, return true if it contains a 2, 7, 1 pattern -- \n * a value, followed by the value plus 5, followed by the value minus 1. \n * Additionally the 271 counts even if the \"1\" differs by 2 or less from the \n * correct value.\n */\npublic boolean has271(int[] nums) {\n    for(int i = 0; i < nums.length - 2; i++) {\n        if((nums[i+1] == nums[i] + 5) && \n            (Math.abs(nums[i+2] - (nums[i] - 1)) <= 2))\n            return true;\n    }\n                \n    return false;\n}\n"}, "helloName": {"id": "p171896", "code": "/* Given a string name, e.g. \"Bob\", return a greeting of the form \"Hello Bob!\".\n */\npublic String helloName(String name) {\n    return \"Hello \" + name + \"!\";\n}\n"}, "makeAbba": {"id": "p161056", "code": "/* Given two strings, a and b, return the result of putting them together in \n * the order abba, e.g. \"Hi\" and \"Bye\" returns \"HiByeByeHi\".\n */\npublic String makeAbba(String a, String b) {\n    return a + b + b + a;\n}\n"}, "makeTags": {"id": "p147483", "code": "/* The web is built with HTML strings like \"<i>Yay</i>\" which draws Yay as \n * italic text. In this example, the \"i\" tag makes <i> and </i> which surround \n * the word \"Yay\". Given tag and word strings, create the HTML string with \n * tags around the word, e.g. \"<i>Yay</i>\".\n */\npublic String makeTags(String tag, String word) {\n    return \"<\" + tag + \">\" + word + \"</\" + tag + \">\";\n}\n"}, "makeOutWord": {"id": "p184030", "code": "/* Given an \"out\" string length 4, such as \"<<>>\", and a word, return a new \n * string where the word is in the middle of the out string, e.g. \"<<word>>\". \n * Note: use str.substring(i, j) to extract the String starting at index i and \n * going up to but not including index j.\n */\npublic String makeOutWord(String out, String word) {\n    return out.substring(0, 2) + word + out.substring(2);\n}\n"}, "extraEnd": {"id": "p108853", "code": "/* Given a string, return a new string made of 3 copies of the last 2 chars \n * of the original string. The string length will be at least 2.\n */\npublic String extraEnd(String str) {\n    String last = str.substring(str.length() - 2);\n    return last + last + last;\n}\n"}, "firstTwo": {"id": "p163411", "code": "/* Given a string, return the string made of its first two chars, so the \n * String \"Hello\" yields \"He\". If the string is shorter than length 2, return \n * whatever there is, so \"X\" yields \"X\", and the empty string \"\" yields the \n * empty string \"\".\n */\npublic String firstTwo(String str) {\n    if(str.length() < 2)\n        return str;\n          \n    return str.substring(0, 2);\n}\n"}, "firstHalf": {"id": "p172267", "code": "/* Given a string of even length, return the first half. So the string \n * \"WooHoo\" yields \"Woo\".\n */\npublic String firstHalf(String str) {\n    return str.substring(0, str.length() / 2);\n}\n"}, "withoutEnd": {"id": "p130896", "code": "/* Given a string, return a version without the first and last char, so \n * \"Hello\" yields \"ell\". The string length will be at least 2.\n */\npublic String withoutEnd(String str) {\n    return str.substring(1, str.length() - 1);\n}\n"}, "comboString": {"id": "p168564", "code": "/* Given 2 strings, a and b, return a string of the form short+long+short, \n * with the shorter string on the outside and the longer string on the \n * inside. The strings will not be the same length, but they may be empty \n * (length 0).\n */\npublic String comboString(String a, String b) {\n    if(b.length() < a.length()) {\n        String temp = a;\n        a = b;\n        b = temp;\n    }\n                  \n    return a + b + a;\n}\n"}, "nonStart": {"id": "p143825", "code": "/* Given 2 strings, return their concatenation, except omit the first char of \n * each. The strings will be at least length 1.\n */\npublic String nonStart(String a, String b) {\n    return a.substring(1) + b.substring(1);\n}\n"}, "left2": {"id": "p197720", "code": "/* Given a string, return a \"rotated left 2\" version where the first 2 chars \n * are moved to the end. The string length will be at least 2.\n */\npublic String left2(String str) {\n    return str.substring(2) + str.substring(0, 2);\n}\n"}, "right2": {"id": "p130781", "code": "/* Given a string, return a \"rotated right 2\" version where the last 2 chars \n * are moved to the start. The string length will be at least 2.\n */\npublic String right2(String str) {\n    return str.substring(str.length() - 2) + \n        str.substring(0, str.length() - 2);\n}\n"}, "theEnd": {"id": "p162477", "code": "/* Given a string, return a string length 1 from its front, unless front is \n * false, in which case return a string length 1 from its back. The string \n * will be non-empty.\n */\npublic String theEnd(String str, boolean front) {\n    if(front)\n        return str.substring(0,1);\n          \n    return str.substring(str.length() - 1);\n}\n"}, "withouEnd2": {"id": "p174254"}, "middleTwo": {"id": "p137729", "code": "/* Given a string of even length, return a string made of the middle two \n * chars, so the string \"string\" yields \"ri\". The string length will be at \n * least 2.\n */\npublic String middleTwo(String str) {\n    return str.substring(str.length() / 2 - 1, str.length() / 2 + 1);\n}\n"}, "endsLy": {"id": "p103895", "code": "/* Given a string, return true if it ends in \"ly\".\n */\npublic boolean endsLy(String str) {\n    if(str.length() < 2)\n        return false;\n          \n    return str.substring(str.length() - 2).equals(\"ly\");\n}\n"}, "nTwice": {"id": "p174148", "code": "/* Given a string and an int n, return a string made of the first and last n \n * chars from the string. The string length will be at least n.\n */\npublic String nTwice(String str, int n) {\n    return str.substring(0, n) + str.substring(str.length() - n);\n}\n"}, "twoChar": {"id": "p144623", "code": "/* Given a string and an index, return a string length 2 starting at the \n * given index. If the index is too big or too small to define a string \n * length 2, use the first 2 chars. The string length will be at least 2.\n */\npublic String twoChar(String str, int index) {\n    if(index + 2 > str.length() || index < 0)\n        return str.substring(0, 2);\n          \n    return str.substring(index, index + 2);\n}\n"}, "middleThree": {"id": "p115863", "code": "/* Given a string of odd length, return the string length 3 from its middle, \n * so \"Candy\" yields \"and\". The string length will be at least 3.\n */\npublic String middleThree(String str) {\n    int mid = str.length() / 2;\n    return str.substring(mid - 1, mid + 2);\n}\n"}, "hasBad": {"id": "p139075", "code": "/* Given a string, return true if \"bad\" appears starting at index 0 or 1 in \n * the string, such as with \"badxxx\" or \"xbadxx\" but not \"xxbadxx\". The \n * string may be any length, including 0. Note: use .equals() to compare 2 \n * strings.\n */\npublic boolean hasBad(String str) {\n    if(str.length() == 3)\n        return str.substring(0, 3).equals(\"bad\");\n          \n    if(str.length() >= 4)\n        return str.substring(0, 3).equals(\"bad\") || \n            str.substring(1, 4).equals(\"bad\");\n                    \n    return false;\n}\n"}, "atFirst": {"id": "p139076", "code": "/* Given a string, return a string length 2 made of its first 2 chars. If the \n * string length is less than 2, use '@' for the missing chars.\n */\npublic String atFirst(String str) {\n    if(str.length() == 0)\n        return \"@@\";\n          \n    if(str.length() == 1)\n        return str + \"@\";\n                    \n    return str.substring(0, 2);\n}\n"}, "lastChars": {"id": "p138183", "code": "/* Given 2 strings, a and b, return a new string made of the first char of a \n * and the last char of b, so \"yo\" and \"java\" yields \"ya\". If either string \n * is length 0, use '@' for its missing char.\n */\npublic String lastChars(String a, String b) {\n    String first = \"@\";\n    String last = \"@\";;\n      \n    if(a.length() > 0)\n        first = a.substring(0,1);\n                \n    if(b.length() > 0)\n        last = b.substring(b.length() - 1);\n                          \n    return first + last;\n}\n"}, "conCat": {"id": "p132118", "code": "/* Given two strings, append them together (known as \"concatenation\") and \n * return the result. However, if the concatenation creates a double-char, \n * then omit one of the chars, so \"abc\" and \"cat\" yields \"abcat\".\n */\npublic String conCat(String a, String b) {\n    if(a.length() == 0 || b.length() == 0)\n        return a + b;\n          \n    if(a.charAt(a.length() - 1) == b.charAt(0))\n        return a + b.substring(1);\n                    \n    return a + b;\n}\n"}, "lastTwo": {"id": "p194786", "code": "/* Given a string of any length, return a new string where the last 2 chars, \n * if present, are swapped, so \"coding\" yields \"codign\".\n */\npublic String lastTwo(String str) {\n    if(str.length() < 2)\n        return str;\n          \n    return str.substring(0, str.length() - 2) + str.charAt(str.length() - 1) +\n        str.charAt(str.length() - 2);\n}\n"}, "seeColor": {"id": "p199216", "code": "/* Given a string, if the string begins with \"red\" or \"blue\" return that \n * color string, otherwise return the empty string.\n */\npublic String seeColor(String str) {\n    if(str.length() >= 3 && str.substring(0, 3).equals(\"red\"))\n        return \"red\";\n          \n    if(str.length() >= 4 && str.substring(0, 4).equals(\"blue\"))\n        return \"blue\";\n                    \n    return \"\";\n}\n"}, "frontAgain": {"id": "p196652", "code": "/* Given a string, return true if the first 2 chars in the string also appear \n * at the end of the string, such as with \"edited\".\n */\npublic boolean frontAgain(String str) {\n    if(str.length() < 2)\n        return false;\n    return str.substring(0, 2).equals(str.substring(str.length() - 2));\n}\n"}, "minCat": {"id": "p105745", "code": "/* Given two strings, append them together (known as \"concatenation\") and \n * return the result. However, if the strings are different lengths, omit \n * chars from the longer string so it is the same length as the shorter \n * string. So \"Hello\" and \"Hi\" yield \"loHi\". The strings may be any length.\n */\npublic String minCat(String a, String b) {\n    int min = Math.min(a.length(), b.length());\n    \n    return a.substring(a.length() - min) + b.substring(b.length() - min);\n}\n"}, "extraFront": {"id": "p172063", "code": "/* Given a string, return a new string made of 3 copies of the first 2 chars \n * of the original string. The string may be any length. If there are fewer \n * than 2 chars, use whatever is there.\n */\npublic String extraFront(String str) {\n    if(str.length() >= 2)\n        str = str.substring(0, 2);\n          \n    return str + str + str;\n}\n"}, "without2": {"id": "p142247", "code": "/* Given a string, if a length 2 substring appears at both its beginning and \n * end, return a string without the substring at the beginning, so \"HelloHe\" \n * yields \"lloHe\". The substring may overlap with itself, so \"Hi\" yields \"\". \n * Otherwise, return the original string unchanged.\n */\npublic String without2(String str) {\n    if(str.length () >= 2 && \n        str.substring(0, 2).equals(str.substring(str.length() - 2)))\n        return str.substring(2);\n              \n    return str;\n}\n"}, "deFront": {"id": "p110141", "code": "/* Given a string, return a version without the first 2 chars. Except keep \n * the first char if it is 'a' and keep the second char if it is 'b'. The \n * string may be any length. Harder than it looks.\n */\npublic String deFront(String str) {\n    if(str.length() == 1 && str.charAt(0) != 'a')\n        return \"\";\n          \n    if(str.length() >= 2) {\n        if(str.charAt(0) != 'a' && str.charAt(1) != 'b') {\n            return str.substring(2);\n        } else if(str.charAt(0) != 'a') {\n            return str.substring(1);\n        } else if(str.charAt(1) != 'b') {\n            return \"a\" + str.substring(2);\n        }\n    }\n                                                  \n    return str;\n}\n"}, "startWord": {"id": "p141494", "code": "/* Given a string and a second \"word\" string, we'll say that the word matches \n * the string if it appears at the front of the string, except its first char \n * does not need to match exactly. On a match, return the front of the string, \n * or otherwise return the empty string. So, so with the string \"hippo\" the \n * word \"hi\" returns \"hi\" and \"xip\" returns \"hip\". The word will be at least \n * length 1.\n */\npublic String startWord(String str, String word) {\n    if(str.length() >= word.length() && \n        str.substring(1, word.length()).equals(word.substring(1)))\n        return str.substring(0, word.length());\n                  \n    return \"\";\n}\n"}, "withoutX": {"id": "p151940", "code": "/* Given a string, if the first or last chars are 'x', return the string \n * without those 'x' chars, and otherwise return the string unchanged.\n */\npublic String withoutX(String str) {\n    int begin = 0;\n    int end = str.length();\n      \n    if(str.length() > 0 && str.charAt(0) == 'x')\n        begin = 1;\n                \n    if(str.length() > 1 && str.charAt(str.length() - 1) == 'x')\n        end--;\n                          \n    return str.substring(begin, end);\n}\n"}, "withoutX2": {"id": "p151359", "code": "/* Given a string, if one or both of the first 2 chars is 'x', return the \n * string without those 'x' chars, and otherwise return the string unchanged. \n * This is a little harder than it looks.\n */\npublic String withoutX2(String str) {\n    if(str.length() == 1 && str.charAt(0) == 'x')\n        return \"\";\n          \n    if(str.length() >= 2) {\n        if(str.charAt(0) == 'x' && str.charAt(1) == 'x') {\n            return str.substring(2);\n        } else if(str.charAt(0) == 'x') {\n            return str.substring(1);\n        } else if(str.charAt(1) == 'x') {\n            return str.charAt(0) + str.substring(2);\n        }\n    }\n                                                  \n    return str;\n}\n"}, "firstLast6": {"id": "p185685", "code": "/* Given an array of ints, return true if 6 appears as either the first or \n * last element in the array. The array will be length 1 or more.\n */\npublic boolean firstLast6(int[] nums) {\n    return nums[0] == 6 || nums[nums.length - 1] == 6;\n}\n"}, "sameFirstLast": {"id": "p118976", "code": "/* Given an array of ints, return true if the array is length 1 or more, and \n * the first element and the last element are equal.\n */\npublic boolean sameFirstLast(int[] nums) {\n    return nums.length > 0 && nums[0] == nums[nums.length - 1];\n}\n"}, "makePi": {"id": "p167011", "code": "/* Return an int array length 3 containing the first 3 digits of pi, {3, 1, 4}.\n */\npublic int[] makePi() {\n    int[] nums = {3, 1, 4};\n    return nums;\n}\n"}, "commonEnd": {"id": "p191991", "code": "/* Given 2 arrays of ints, a and b, return true if they have the same first \n * element or they have the same last element. Both arrays will be length 1 or \n * more.\n */\npublic boolean commonEnd(int[] a, int[] b) {\n    return a[0] == b[0] || a[a.length - 1] == b[b.length - 1];\n}\n"}, "sum3": {"id": "p175763", "code": "/* Given an array of ints length 3, return the sum of all the elements.\n */\npublic int sum3(int[] nums) {\n    return nums[0] + nums[1] + nums[2];\n}\n"}, "rotateLeft3": {"id": "p185139", "code": "/* Given an array of ints length 3, return an array with the elements \n * \"rotated left\" so {1, 2, 3} yields {2, 3, 1}.\n */\npublic int[] rotateLeft3(int[] nums) {\n    return new int[] {nums[1], nums[2], nums[0]};\n}\n"}, "reverse3": {"id": "p112409", "code": "/* Given an array of ints length 3, return a new array with the elements in \n * reverse order, so {1, 2, 3} becomes {3, 2, 1}.\n */\npublic int[] reverse3(int[] nums) {\n    return new int[] {nums[2], nums[1], nums[0]};\n}\n"}, "maxEnd3": {"id": "p146256", "code": "/* Given an array of ints length 3, figure out which is larger between the \n * first and last elements in the array, and set all the other elements to be \n * that value. Return the changed array.\n */\npublic int[] maxEnd3(int[] nums) {\n    int max = nums[0] > nums[2] ? nums[0] : nums[2];\n    \n    nums[0] = max;\n    nums[1] = max;\n    nums[2] = max;\n            \n    return nums;\n}\n"}, "sum2": {"id": "p190968", "code": "/* Given an array of ints, return the sum of the first 2 elements in the \n * array. If the array length is less than 2, just sum up the elements that \n * exist, returning 0 if the array is length 0.\n */\npublic int sum2(int[] nums) {\n    if(nums.length == 0)\n        return 0;\n          \n    if(nums.length == 1)\n        return nums[0];\n                    \n    return nums[0] + nums[1];\n}\n"}, "middleWay": {"id": "p146449", "code": "/* Given 2 int arrays, a and b, each length 3, return a new array length 2 \n * containing their middle elements.\n */\npublic int[] middleWay(int[] a, int[] b) {\n    return new int[] {a[1], b[1]};\n}\n"}, "makeEnds": {"id": "p101230", "code": "/* Given an array of ints, return a new array length 2 containing the first \n * and last elements from the original array. The original array will be \n * length 1 or more.\n */\npublic int[] makeEnds(int[] nums) {\n    return new int[] {nums[0], nums[nums.length - 1]};\n}\n"}, "has23": {"id": "p171022", "code": "/* Given an int array length 2, return true if it contains a 2 or a 3.\n */\npublic boolean has23(int[] nums) {\n    for(int i = 0; i < nums.length; i++) {\n        if(nums[i] == 2 || nums[i] == 3)\n            return true;\n    }\n                \n    return false;\n}\n"}, "no23": {"id": "p175689", "code": "/* Given an int array length 2, return true if it does not contain a 2 or 3.\n */\npublic boolean no23(int[] nums) {\n    for(int i = 0; i < nums.length; i++) {\n        if(nums[i] == 2 || nums[i] == 3)\n            return false;\n    }\n                \n    return true;\n}\n"}, "makeLast": {"id": "p137188", "code": "/* Given an int array, return a new array with double the length where its \n * last element is the same as the original array, and all the other elements \n * are 0. The original array will be length 1 or more. Note: by default, a \n * new int array contains all 0's.\n */\npublic int[] makeLast(int[] nums) {\n    int[] arr = new int[2 * nums.length];\n    arr[arr.length - 1] = nums[nums.length - 1];\n    return arr;\n}\n"}, "double23": {"id": "p145365", "code": "/* Given an int array, return true if the array contains 2 twice, or 3 twice. \n * The array will be length 0, 1, or 2.\n */\npublic boolean double23(int[] nums) {\n    int count2 = 0;\n    int count3 = 0;\n      \n    for(int i = 0; i < nums.length; i++) {\n        if(nums[i] == 2)\n            count2++;\n                        \n        if(nums[i] == 3)\n            count3++;\n    }\n                                      \n    return count2 == 2 || count3 == 2;\n}\n"}, "fix23": {"id": "p120347", "code": "/* Given an int array length 3, if there is a 2 in the array immediately \n * followed by a 3, set the 3 element to 0. Return the changed array.\n */\npublic int[] fix23(int[] nums) {\n    for(int i = 0; i < nums.length - 1; i++) {\n        if(nums[i] == 2 && nums[i + 1] == 3)\n            nums[i + 1] = 0;\n    }\n                \n    return nums;\n}\n"}, "start1": {"id": "p109660", "code": "/* Start with 2 int arrays, a and b, of any length. Return how many of the \n * arrays have 1 as their first element.\n */\npublic int start1(int[] a, int[] b) {\n    int count = 0;\n    \n    if(a.length > 0 && a[0] == 1)\n        count++;\n              \n    if(b.length > 0 && b[0] == 1)\n        count++;\n                        \n    return count;\n}\n"}, "biggerTwo": {"id": "p109537", "code": "/* Start with 2 int arrays, a and b, each length 2. Consider the sum of the \n * values in each array. Return the array which has the largest sum. In event \n * of a tie, return a.\n */\npublic int[] biggerTwo(int[] a, int[] b) {\n    if(a[0] + a[1] < b[0] + b[1])\n        return b;\n          \n    return a;\n}\n"}, "makeMiddle": {"id": "p199519", "code": "/* Given an array of ints of even length, return a new array length 2 \n * containing the middle two elements from the original array. The original \n * array will be length 2 or more.\n */\npublic int[] makeMiddle(int[] nums) {\n    return new int[] {nums[nums.length / 2 - 1], nums[nums.length / 2]};\n}\n"}, "plusTwo": {"id": "p180840", "code": "/* Given 2 int arrays, each length 2, return a new array length 4 containing \n * all their elements.\n */\npublic int[] plusTwo(int[] a, int[] b) {\n    return new int[] {a[0], a[1], b[0], b[1]};\n}\n"}, "swapEnds": {"id": "p118044", "code": "/* Given an array of ints, swap the first and last elements in the array. \n * Return the modified array. The array length will be at least 1.\n */\npublic int[] swapEnds(int[] nums) {\n    int temp = nums[0];\n    nums[0] = nums[nums.length - 1];\n    nums[nums.length - 1] = temp;\n    return nums;\n}\n"}, "midThree": {"id": "p155713", "code": "/* Given an array of ints of odd length, return a new array length 3 \n * containing the elements from the middle of the array. The array length \n * will be at least 3.\n */\npublic int[] midThree(int[] nums) {\n    int[] arr = new int[3];\n    arr[0] = nums[nums.length / 2 - 1];\n    arr[1] = nums[nums.length / 2];\n    arr[2] = nums[nums.length / 2 + 1];\n    return arr;\n}\n"}, "maxTriple": {"id": "p185176", "code": "/* Given an array of ints of odd length, look at the first, last, and middle \n * values in the array and return the largest. The array length will be a \n * least 1.\n */\npublic int maxTriple(int[] nums) {\n    int max = nums[0];\n    \n    if(max < nums[nums.length / 2])\n        max = nums[nums.length / 2];\n              \n    if(max < nums[nums.length - 1])\n        max = nums[nums.length - 1];\n                        \n    return max;\n}\n"}, "frontPiece": {"id": "p142455", "code": "/* Given an int array of any length, return a new array of its first 2 \n * elements. If the array is smaller than length 2, use whatever elements are \n * present.\n */\npublic int[] frontPiece(int[] nums) {\n    int[] arr;\n    if(nums.length < 2)\n        arr = new int[nums.length];\n    else\n        arr = new int[2];\n                  \n    if(nums.length > 0)\n        arr[0] = nums[0];\n                            \n    if(nums.length > 1)\n        arr[1] = nums[1];\n                                    \n    return arr;\n}\n"}, "unlucky1": {"id": "p197308", "code": "/* We'll say that a 1 immediately followed by a 3 in an array is an \"unlucky\" \n * 1. Return true if the given array contains an unlucky 1 in the first 2 or \n * last 2 positions in the array.\n */\npublic boolean unlucky1(int[] nums) {\n    if(nums.length >= 2 && \n        (nums[0] == 1 && nums[1] == 3 || nums[nums.length - 2] == 1 && \n        nums[nums.length - 1] == 3))\n        return true;\n                       \n    if(nums.length >= 3 && nums[1] == 1 && nums[2] == 3)\n        return true;\n                                 \n    return false;\n}\n"}, "make2": {"id": "p143461", "code": "/* Given 2 int arrays, a and b, return a new array length 2 containing, as \n * much as will fit, the elements from a followed by the elements from b. The \n * arrays may be any length, including 0, but there will be 2 or more \n * elements available between the 2 arrays.\n */\npublic int[] make2(int[] a, int[] b) {\n    int[] arr = new int[2];\n    int count = 0;\n    int i;\n        \n    i = 0;\n    while(count < 2 && i < a.length) {\n        arr[count] = a[i];\n        count++;\n        i++;\n    }\n                            \n    i = 0;\n    while(count < 2 && i < b.length) {\n        arr[count] = b[i];\n        count++;\n        i++;\n    }\n                                                \n    return arr;\n}\n"}, "front11": {"id": "p128270", "code": "/* Given 2 int arrays, a and b, of any length, return a new array with the \n * first element of each array. If either array is length 0, ignore that array.\n */\npublic int[] front11(int[] a, int[] b) {\n    if(a.length > 0 && b.length > 0) {\n        return new int[] {a[0], b[0]};\n    } else if(a.length > 0) {\n        return new int[] {a[0]};\n    } else if(b.length > 0) {\n        return new int[] {b[0]};\n    }\n                      \n    return new int[0];\n}\n"}, "cigarParty": {"id": "p159531", "code": "/* When squirrels get together for a party, they like to have cigars. A \n * squirrel party is successful when the number of cigars is between 40 and \n * 60, inclusive. Unless it is the weekend, in which case there is no upper \n * bound on the number of cigars. Return true if the party with the given \n * values is successful, or false otherwise.\n */\npublic boolean cigarParty(int cigars, boolean isWeekend) {\n    if(isWeekend)\n        return 40 <= cigars;\n          \n    return 40 <= cigars && cigars <= 60;\n}\n"}, "dateFashion": {"id": "p103360", "code": "/* You and your date are trying to get a table at a restaurant. The parameter \n * \"you\" is the stylishness of your clothes, in the range 0..10, and \"date\" \n * is the stylishness of your date's clothes. The result getting the table is \n * encoded as an int value with 0=no, 1=maybe, 2=yes. If either of you is \n * very stylish, 8 or more, then the result is 2 (yes). With the exception \n * that if either of you has style of 2 or less, then the result is 0 (no). \n * Otherwise the result is 1 (maybe).\n */\npublic int dateFashion(int you, int date) {\n    if(you <= 2 || date <= 2)\n        return 0;\n          \n    if(you >= 8 || date >= 8)\n        return 2;\n                    \n    return 1;\n}\n"}, "squirrelPlay": {"id": "p141061", "code": "/* The squirrels in Palo Alto spend most of the day playing. In particular, \n * they play if the temperature is between 60 and 90 (inclusive). Unless it \n * is summer, then the upper limit is 100 instead of 90. Given an int \n * temperature and a boolean isSummer, return true if the squirrels play and \n * false otherwise.\n */\npublic boolean squirrelPlay(int temp, boolean isSummer) {\n    if(isSummer && 60 <= temp && temp <= 100)\n        return true;\n          \n    if(!isSummer && 60 <= temp && temp <= 90)\n        return true;\n                    \n    return false;\n}\n"}, "caughtSpeeding": {"id": "p157733", "code": "/* You are driving a little too fast, and a police officer stops you. Write \n * code to compute the result, encoded as an int value: 0=no ticket, 1=small \n * ticket, 2=big ticket. If speed is 60 or less, the result is 0. If speed is \n * between 61 and 80 inclusive, the result is 1. If speed is 81 or more, the \n * result is 2. Unless it is your birthday -- on that day, your speed can be \n * 5 higher in all cases.\n */\npublic int caughtSpeeding(int speed, boolean isBirthday) {\n    if(isBirthday) {\n        if(speed <= 65) {\n            return 0;\n        } else if(66 <= speed && speed <= 85) {\n            return 1;\n        } else if(86 <=  speed) {\n            return 2;\n        }\n    }\n                                        \n    if(speed <= 60) {\n        return 0;\n    } else if(61 <= speed && speed <= 80) {\n        return 1;\n    } else {\n        return 2;\n    }\n}\n"}, "sortaSum": {"id": "p183071", "code": "/* Given 2 ints, a and b, return their sum. However, sums in the \n * range 10..19 inclusive, are forbidden, so in that case just return 20.\n */\npublic int sortaSum(int a, int b) {\n    int sum = a + b;\n    \n    if(10 <= sum && sum <= 19)\n        return 20;\n              \n    return sum;\n}\n"}, "alarmClock": {"id": "p160543", "code": "/* Given a day of the week encoded as 0=Sun, 1=Mon, 2=Tue, ...6=Sat, and a \n * boolean indicating if we are on vacation, return a string of the form \n * \"7:00\" indicating when the alarm clock should ring. Weekdays, the alarm \n * should be \"7:00\" and on the weekend it should be \"10:00\". Unless we are on \n * vacation -- then on weekdays it should be \"10:00\" and weekends it should \n * be \"off\".\n */\npublic String alarmClock(int day, boolean vacation) {\n    if(vacation) {\n        if(day == 0 || day == 6)\n            return \"off\";\n        else\n            return \"10:00\";\n    }\n                          \n    if(day == 0 || day == 6)\n        return \"10:00\";\n                                    \n    return \"7:00\";\n}\n"}, "love6": {"id": "p137742", "code": "/* The number 6 is a truly great number. Given two int values, a and b, \n * return true if either one is 6. Or if their sum or difference is 6. Note: \n * the function Math.abs(num) computes the absolute value of a number.\n */\npublic boolean love6(int a, int b) {\n    if(a == 6 || b == 6 || a + b == 6 || Math.abs(a - b) == 6)\n        return true;\n          \n    return false;\n}\n"}, "in1To10": {"id": "p137365", "code": "/* Given a number n, return true if n is in the range 1..10, inclusive. \n * Unless \"outsideMode\" is true, in which case return true if the number is \n * less or equal to 1, or greater or equal to 10.\n */\npublic boolean in1To10(int n, boolean outsideMode) {\n    if(outsideMode)\n        return n <= 1 || 10 <= n;\n          \n    return 1 <= n && n <= 10;\n}\n"}, "specialEleven": {"id": "p100962", "code": "/* We'll say a number is special if it is a multiple of 11 or if it is one \n * more than a multiple of 11. Return true if the given non-negative number \n * is special.\n */\npublic boolean specialEleven(int n) {\n    return (n % 11) == 0 || (n % 11) == 1;\n}\n"}, "more20": {"id": "p118290", "code": "/* Return true if the given non-negative number is 1 or 2 more than a \n * multiple of 20.\n */\npublic boolean more20(int n) {\n    return n % 20 == 1 || n % 20 == 2;\n}\n"}, "old35": {"id": "p159612", "code": "/* Return true if the given non-negative number is a multiple of 3 or 5, but \n * not both.\n */\npublic boolean old35(int n) {\n    return (n % 3 == 0) != (n % 5 == 0);\n}\n"}, "less20": {"id": "p133158", "code": "/* Return true if the given non-negative number is 1 or 2 less than a \n * multiple of 20. So for example 38 and 39 return true, but 40 returns false.\n */\npublic boolean less20(int n) {\n    return n % 20 == 19 || n % 20 == 18;\n}\n"}, "nearTen": {"id": "p193613", "code": "/* Given a non-negative number \"num\", return true if num is within 2 of a \n * multiple of 10.\n */\npublic boolean nearTen(int num) {\n    return num % 10 <= 2 || num % 10 >= 8;\n}\n"}, "teenSum": {"id": "p178728", "code": "/* Given 2 ints, a and b, return their sum. However, \"teen\" values in the \n * range 13..19 inclusive, are extra lucky. So if either value is a teen, \n * just return 19.\n */\npublic int teenSum(int a, int b) {\n    if((13 <= a && a <= 19) || (13 <= b && b <= 19))\n        return 19;\n          \n    return a + b;\n}\n"}, "answerCell": {"id": "p110973", "code": "/* Your cell phone rings. Return true if you should answer it. Normally you \n * answer, except in the morning you only answer if it is your mom calling. \n * In all cases, if you are asleep, you do not answer.\n */\npublic boolean answerCell(boolean isMorning, boolean isMom, boolean isAsleep) {\n    if(isAsleep)\n        return false;\n          \n    if(isMorning && !isMom)\n        return false;\n                    \n    return true;\n}\n"}, "teaParty": {"id": "p177181", "code": "/* We are having a party with amounts of tea and candy. Return the int \n * outcome of the party encoded as 0=bad, 1=good, or 2=great. A party is good \n * (1) if both tea and candy are at least 5. However, if either tea or candy \n * is at least double the amount of the other one, the party is great (2). \n * However, in all cases, if either tea or candy is less than 5, the party is \n * always bad (0).\n */\npublic int teaParty(int tea, int candy) {\n    if(tea < 5 || candy < 5)\n        return 0;\n          \n    if(tea >= 2 * candy || candy >= 2 * tea)\n        return 2;\n                  \n    return 1;\n}\n"}, "fizzString": {"id": "p137136", "code": "/* Given a string str, if the string starts with \"f\" return \"Fizz\". If the \n * string ends with \"b\" return \"Buzz\". If both the \"f\" and \"b\" conditions are \n * true, return \"FizzBuzz\". In all other cases, return the string unchanged.\n */\npublic String fizzString(String str) {\n    if(str.length() > 0 && \n        str.charAt(0) == 'f' && str.charAt(str.length() - 1) == 'b')\n        return \"FizzBuzz\";\n              \n    if(str.length() > 0 && str.charAt(0) == 'f')\n        return \"Fizz\";\n                        \n    if(str.length() > 0 && str.charAt(str.length() - 1) == 'b')\n        return \"Buzz\";\n                                  \n    return str;\n}\n"}, "fizzString2": {"id": "p115243", "code": "/* Given an int n, return the string form of the number followed by \"!\". So \n * the int 6 yields \"6!\". Except if the number is divisible by 3 use \"Fizz\" \n * instead of the number, and if the number is divisible by 5 use \"Buzz\", and \n * if divisible by both 3 and 5, use \"FizzBuzz\".\n */\npublic String fizzString2(int n) {\n    if(n % 15 == 0)\n        return \"FizzBuzz!\";\n          \n    if(n % 3 == 0)\n        return \"Fizz!\";\n                    \n    if(n % 5 == 0)\n        return \"Buzz!\";\n                              \n    return n + \"!\";\n}\n"}, "twoAsOne": {"id": "p113261", "code": "/* Given three ints, a b c, return true if it is possible to add two of the \n * ints to get the third.\n */\npublic boolean twoAsOne(int a, int b, int c) {\n    return a + b == c || a + c == b || b + c == a;\n}\n"}, "inOrder": {"id": "p154188", "code": "/* Given three ints, a b c, return true if b is greater than a, and c is \n * greater than b. However, with the exception that if \"bOk\" is true, b does \n * not need to be greater than a.\n */\npublic boolean inOrder(int a, int b, int c, boolean bOk) {\n    if(bOk)\n        return c > b;\n        \n    return b > a && c > b;\n}\n"}, "inOrderEqual": {"id": "p140272", "code": "/* Given three ints, a b c, return true if they are in strict increasing \n * order, such as 2 5 11, or 5 6 7, but not 6 5 7 or 5 5 7. However, with the \n * exception that if \"equalOk\" is true, equality is allowed, such as \n * 5 5 7 or 5 5 5.\n */\npublic boolean inOrderEqual(int a, int b, int c, boolean equalOk) {\n    if(equalOk)\n        return a <= b && b <= c;\n          \n    return a < b && b < c;\n}\n"}, "lessBy10": {"id": "p179196", "code": "/* Given three ints, a b c, return true if one of them is 10 or more less \n * than one of the others.\n */\npublic boolean lessBy10(int a, int b, int c) {\n    return  Math.abs(a - b) >= 10 || Math.abs(a - c) >= 10 || \n        Math.abs(b - c) >= 10;\n}\n"}, "withoutDoubles": {"id": "p115233", "code": "/* Return the sum of two 6-sided dice rolls, each in the range 1..6. However, \n * if noDoubles is true, if the two dice show the same value, increment one \n * die to the next value, wrapping around to 1 if its value was 6.\n */\npublic int withoutDoubles(int die1, int die2, boolean noDoubles) {\n    if(noDoubles && die1 == die2) {\n        die1++;\n        if(die1 == 7)\n            die1 = 1;\n    }\n                      \n    return die1 + die2;\n}\n"}, "maxMod5": {"id": "p115384", "code": "/* Given two int values, return whichever value is larger. However if the two \n * values have the same remainder when divided by 5, then the return the \n * smaller value. However, in all cases, if the two values are the same, \n * return 0.\n */\npublic int maxMod5(int a, int b) {\n    if(a == b)\n        return 0;\n          \n    if(a % 5 == b % 5)\n        return a < b ? a : b;\n                    \n    return a > b ? a : b;\n}\n"}, "redTicket": {"id": "p170833", "code": "/* You have a red lottery ticket showing ints a, b, and c, each of which is \n * 0, 1, or 2. If they are all the value 2, the result is 10. Otherwise if \n * they are all the same, the result is 5. Otherwise so long as both b and c \n * are different from a, the result is 1. Otherwise the result is 0.\n */\npublic int redTicket(int a, int b, int c) {\n    if(a == 2 && b == 2 && c == 2)\n        return 10;\n          \n    if(a == b && b == c)\n        return 5;\n                    \n    if(a != b && a != c)\n        return 1;\n                            \n    return 0;\n}\n"}, "greenTicket": {"id": "p120633", "code": "/* You have a green lottery ticket, with ints a, b, and c on it. If the \n * numbers are all different from each other, the result is 0. If all of the \n * numbers are the same, the result is 20. If two of the numbers are the \n * same, the result is 10.\n */\npublic int greenTicket(int a, int b, int c) {\n    if(a == b && b == c)\n        return 20;\n          \n    if(a == b || a == c || b == c)\n        return 10;\n                  \n    return 0;\n}\n"}, "blueTicket": {"id": "p192267", "code": "/* You have a blue lottery ticket, with ints a, b, and c on it. This makes \n * three pairs, which we'll call ab, bc, and ac. Consider the sum of the \n * numbers in each pair. If any pair sums to exactly 10, the result is 10. \n * Otherwise if the ab sum is exactly 10 more than either bc or ac sums, the \n * result is 5. Otherwise the result is 0.\n */\npublic int blueTicket(int a, int b, int c) {\n    int ab = a + b;\n    int bc = b + c;\n    int ac = a + c;\n        \n    if(ab == 10 || bc == 10 || ac == 10)\n        return 10;\n                  \n    if(ab == bc + 10 || ab == ac + 10)\n        return 5;\n                            \n    return 0;\n}\n"}, "shareDigit": {"id": "p153748", "code": "/* Given two ints, each in the range 10..99, return true if there is a digit \n * that appears in both numbers, such as the 2 in 12 and 23.\n */\npublic boolean shareDigit(int a, int b) {\n    int al = a / 10;\n    int ar = a % 10;\n    int bl = b / 10;\n    int br = b % 10;\n          \n    return al == bl || al == br || ar == bl || ar == br;\n}\n"}, "sumLimit": {"id": "p118077", "code": "/* Given 2 non-negative ints, a and b, return their sum, so long as the sum \n * has the same number of digits as a. If the sum has more digits than a, \n * just return a without b.\n */\npublic int sumLimit(int a, int b) {\n    int sum = a + b;\n    int aLength = String.valueOf(a).length();\n    int sumLength = String.valueOf(sum).length();\n        \n    if(sumLength == aLength)\n        return sum;\n                  \n    return a;\n}\n"}, "makeBricks": {"id": "p183562", "code": "/* We want to make a row of bricks that is goal inches long. We have a number \n * of small bricks (1 inch each) and big bricks (5 inches each). Return true \n * if it is possible to make the goal by choosing from the given bricks.\n */\npublic boolean makeBricks(int small, int big, int goal) {\n    int remainder = goal >= (5 * big) ? goal - (5 * big) : goal % 5;\n    \n    return small >= remainder;\n}\n"}, "loneSum": {"id": "p148972", "code": "/* Given 3 int values, a b c, return their sum. However, if one of the values \n * is the same as another of the values, it does not count towards the sum.\n */\npublic int loneSum(int a, int b, int c) {\n    int sum = 0;\n    \n    if(a != b && a != c)\n        sum += a;\n              \n    if(b != a && b != c)\n        sum += b;\n                        \n    if(c != a && c != b)\n        sum += c;\n                                  \n    return sum;\n}\n"}, "luckySum": {"id": "p130788", "code": "/* Given 3 int values, a b c, return their sum. However, if one of the values \n * is 13 then it does not count towards the sum and values to its right do \n * not count. So for example, if b is 13, then both b and c do not count.\n */\npublic int luckySum(int a, int b, int c) {\n    if(a == 13)\n        return 0;\n           \n    if(b == 13)\n        return a;\n                     \n    if(c == 13)\n        return a + b;\n                               \n    return a + b + c;\n}\n"}, "noTeenSum": {"id": "p182879", "code": "/* Given 3 int values, a b c, return their sum. However, if any of the values \n * is a teen -- in the range 13..19 inclusive -- then that value counts as 0, \n * except 15 and 16 do not count as a teens. Write a separate helper \n * \"public int fixTeen(int n) {\"that takes in an int value and returns that \n * value fixed for the teen rule. In this way, you avoid repeating the teen \n * code 3 times (i.e. \"decomposition\"). Define the helper below and at the \n * same indent level as the main noTeenSum().\n */\npublic int noTeenSum(int a, int b, int c) {\n    return fixTeen(a) + fixTeen(b) + fixTeen(c);\n}\n\npublic int fixTeen(int n) {\n    if(13 <= n && n <= 19 && n != 15 && n != 16)\n        return 0;\n            \n    return n;\n}\n"}, "roundSum": {"id": "p186753", "code": "/* For this problem, we'll round an int value up to the next multiple of 10 \n * if its rightmost digit is 5 or more, so 15 rounds up to 20. Alternately, \n * round down to the previous multiple of 10 if its rightmost digit is less \n * than 5, so 12 rounds down to 10. Given 3 ints, a b c, return the sum of \n * their rounded values. To avoid code repetition, write a separate helper \n * \"public int round10(int num) {\" and call it 3 times. Write the helper \n * entirely below and at the same indent level as roundSum().\n */\npublic int roundSum(int a, int b, int c) {\n    return round10(a) + round10(b) + round10(c);\n}\n\npublic int round10(int num) {\n    int rd = num % 10;\n      \n    if(rd >= 5)\n        return num + 10 - rd;\n                \n    return num - rd;\n}\n"}, "closeFar": {"id": "p138990", "code": "/* Given three ints, a b c, return true if one of b or c is \"close\" \n * (differing from a by at most 1), while the other is \"far\", differing from \n * both other values by 2 or more. Note: Math.abs(num) computes the absolute \n * value of a number.\n */\npublic boolean closeFar(int a, int b, int c) {\n    return (isClose(a, b) && isFar(a, b, c)) ||\n        (isClose(a, c) && isFar(a, c, b));\n}\n\npublic boolean isClose(int a, int b) {\n    return Math.abs(a - b) <= 1;\n}\n\npublic boolean isFar(int a, int b, int c) {\n    return Math.abs(a - c) >= 2 && Math.abs(b - c) >= 2;\n}\n"}, "blackjack": {"id": "p117019", "code": "/* Given 2 int values greater than 0, return whichever value is nearest to 21 \n * without going over. Return 0 if they both go over.\n */\npublic int blackjack(int a, int b) {\n    if(a > 21 && b > 21)\n        return 0;\n          \n    if(a > 21)\n        return b;\n                    \n    if(b > 21)\n        return a;\n                              \n    return a > b ? a : b;\n}\n"}, "evenlySpaced": {"id": "p198700", "code": "/* Given three ints, a b c, one of them is small, one is medium and one is \n * large. Return true if the three values are evenly spaced, so the \n * difference between small and medium is the same as the difference between \n * medium and large.\n */\npublic boolean evenlySpaced(int a, int b, int c) {\n    int temp;\n    if(a > b) {\n        temp = a;\n        a = b;\n        b = temp;\n    }\n                    \n    if(b > c) {\n        temp = b;\n        b = c;\n        c = temp;\n    }\n                                      \n    if(a > b) {\n        temp = a;\n        a = b;\n        b = temp;\n    }\n                                                        \n    return b - a == c - b;\n}\n"}, "makeChocolate": {"id": "p191363", "code": "/* We want make a package of goal kilos of chocolate. We have small bars \n * (1 kilo each) and big bars (5 kilos each). Return the number of small bars \n * to use, assuming we always use big bars before small bars. Return -1 if it \n * can't be done.\n */\npublic int makeChocolate(int small, int big, int goal) {\n    int remainder = goal >= 5 * big ? goal - (5 * big) : goal % 5;\n    \n    return remainder <= small ? remainder : -1;\n}\n"}, "doubleChar": {"id": "p165312", "code": "/* Given a string, return a string where for every char in the original, \n * there are two chars.\n */\npublic String doubleChar(String str) {\n    char[] arr = new char[2 * str.length()];\n    int count = 0;\n      \n    for(int i = 0; i < str.length(); i++) {\n        arr[count] = str.charAt(i);\n        count++;\n        arr[count] = str.charAt(i);\n        count++;\n    }\n                            \n    return new String(arr);\n}\n"}, "countHi": {"id": "p184029", "code": "/* Given a string, compute recursively (no loops) the number of times \n * lowercase \"hi\" appears in the string.\n */\npublic int countHi(String str) {\n    if(str.length() < 2)\n        return 0;\n          \n    if(str.substring(0, 2).equals(\"hi\"))\n        return 1 + countHi(str.substring(2));\n                    \n    return countHi(str.substring(1));\n}\n"}, "catDog": {"id": "p111624", "code": "/* Return true if the string \"cat\" and \"dog\" appear the same number of times \n * in the given string.\n */\npublic boolean catDog(String str) {\n    int cat = 0;\n    int dog = 0;\n      \n    for(int i = 0; i < str.length() - 2; i++) {\n        if(str.substring(i, i + 3).equals(\"cat\"))\n            cat++;\n                        \n        if(str.substring(i, i + 3).equals(\"dog\"))\n            dog++;\n    }\n                                      \n    return cat == dog;\n}\n"}, "countCode": {"id": "p123614", "code": "/* Return the number of times that the string \"code\" appears anywhere in the \n * given string, except we'll accept any letter for the 'd', so \"cope\" and \n * \"cooe\" count.\n */\npublic int countCode(String str) {\n    int count = 0;\n    \n    for(int i = 0; i < str.length() - 3; i++) {\n        if(str.substring(i, i + 2).equals(\"co\") && str.charAt(i + 3) == 'e')\n            count++;\n    }\n                    \n    return count;\n}\n"}, "endOther": {"id": "p126880", "code": "/* Given two strings, return true if either of the strings appears at the \n * very end of the other string, ignoring upper/lower case differences (in \n * other words, the computation should not be \"case sensitive\").\n */\npublic boolean endOther(String a, String b) {\n    if(a.length() < b.length()) {\n        String temp = a;\n        a = b.toLowerCase();\n        b = temp.toLowerCase();\n    }\n                  \n    return a.substring(a.length() - b.length()).equals(b);\n}\n"}, "xyzThere": {"id": "p136594", "code": "/* Return true if the given string contains an appearance of \"xyz\" where the \n * xyz is not directly preceeded by a period (.). So \"xxyz\" counts but \n * \"x.xyz\" does not.\n */\npublic boolean xyzThere(String str) {\n    if(str.length() >= 3 && str.substring(0, 3).equals(\"xyz\"))\n        return true;\n          \n    for(int i = 1; i < str.length() - 2; i++) {\n        if(str.charAt(i - 1) != '.' && str.substring(i, i + 3).equals(\"xyz\"))\n            return true;\n    }\n                          \n    return false;\n}\n"}, "bobThere": {"id": "p175762", "code": "/* Return true if the given string contains a \"bob\" string, but where the \n * middle 'o' char can be any char.\n */\npublic boolean bobThere(String str) {\n    for(int i = 0; i < str.length() - 2; i++) {\n        if(str.charAt(i) == 'b' && str.charAt(i + 2) == 'b')\n            return true;\n    }\n                \n    return false;\n}\n"}, "xyBalance": {"id": "p134250", "code": "/* We'll say that a String is xy-balanced if for all the 'x' chars in the \n * string, there exists a 'y' char somewhere later in the string. So \"xxy\" is \n * balanced, but \"xyx\" is not. One 'y' can balance multiple 'x's. Return true \n * if the given string is xy-balanced.\n */\npublic boolean xyBalance(String str) {\n    boolean y = false;\n    for(int i = str.length() - 1; i >= 0; i--) {\n        if(str.charAt(i) == 'y')\n            y = true;\n                    \n        if(str.charAt(i) == 'x' && !y)\n            return false;\n    }\n                                  \n    return true;\n}\n"}, "mixString": {"id": "p125185", "code": "/* Given two strings, A and B, create a bigger string made of the first char \n * of A, the first char of B, the second char of A, the second char of B, \n * and so on. Any leftover chars go at the end of the result.\n */\npublic String mixString(String a, String b) {\n    char[] arr;\n    String end;\n    int count = 0;\n        \n    if(a.length() < b.length()) {\n        arr = new char[2 * a.length()];\n        end = b.substring(a.length());\n    } else {\n        arr = new char[2 * b.length()];\n        end = a.substring(b.length());\n    }\n                                \n    for(int i = 0; i < arr.length / 2; i++) {\n        arr[count] = a.charAt(i);\n        count++;\n        arr[count] = b.charAt(i);\n        count++;\n    }\n                                                      \n    return new String(arr) + end;\n}\n"}, "repeatEnd": {"id": "p152339", "code": "/* Given a string and an int N, return a string made of N repetitions of the \n * last N characters of the string. You may assume that N is between 0 and \n * the length of the string, inclusive.\n */\npublic String repeatEnd(String str, int n) {\n    StringBuffer result = new StringBuffer();\n    String end = str.substring(str.length() - n);\n      \n    for(int i = 0; i < n; i++)\n        result.append(end);\n                \n    return result.toString();\n}\n"}, "repeatFront": {"id": "p128796", "code": "/* Given a string and an int n, return a string made of the first n \n * characters of the string, followed by the first n-1 characters of the \n * string, and so on. You may assume that n is between 0 and the length of \n * the string, inclusive (i.e. n >= 0 and n <= str.length()).\n */\npublic String repeatFront(String str, int n) {\n    StringBuffer result = new StringBuffer();\n    \n    for(int i = n; i > 0; i--)\n        result.append(str.substring(0, i));\n            \n    return result.toString();\n}\n"}, "repeatSeparator": {"id": "p109637", "code": "/* Given two strings, word and a separator, return a big string made of count \n * occurences of the word, separated by the separator string.\n */\npublic String repeatSeparator(String word, String sep, int count) {\n    if(count == 0)\n        return \"\";\n          \n    StringBuffer result = new StringBuffer();\n              \n    for(int i = 0; i < count - 1; i++) {\n        result.append(word);\n        result.append(sep);\n    }\n                            \n    return result.append(word).toString();\n}\n"}, "prefixAgain": {"id": "p136417", "code": "/* Given a string, consider the prefix string made of the first N chars of \n * the string. Does that prefix string appear somewhere else in the string? \n * Assume that the string is not empty and that N is in the range \n * 1..str.length().\n */\npublic boolean prefixAgain(String str, int n) {\n    String prefix = str.substring(0, n);\n    \n    for(int i = n; i <= str.length() - n; i++) {\n        if(str.substring(i, i + n).equals(prefix))\n            return true;\n    }\n                    \n    return false;\n}\n"}, "xyzMiddle": {"id": "p159772", "code": "/* Given a string, does \"xyz\" appear in the middle of the string? To define \n * middle, we'll say that the number of chars to the left and right of the \n * \"xyz\" must differ by at most one. This problem is harder than it looks.\n */\npublic boolean xyzMiddle(String str) {\n    if(str.length() < 3)\n        return false;\n          \n    int start1 = str.length() / 2 - 2;\n    int start2 = str.length() / 2 - 1;\n                  \n    if(str.length() % 2 == 0) {\n        return str.substring(start1, start1 + 3).equals(\"xyz\") ||\n            str.substring(start2, start2 + 3).equals(\"xyz\");\n    }\n                                  \n    return str.substring(start2, start2 + 3).equals(\"xyz\");\n}\n"}, "getSandwich": {"id": "p129952", "code": "/* A sandwich is two pieces of bread with something in between. Return the \n * string that is between the first and last appearance of \"bread\" in the \n * given string, or return the empty string \"\" if there are not two pieces \n * of bread.\n */\npublic String getSandwich(String str) {\n    int first = -1;\n    int last = -1;\n      \n    for(int i = 0; i < str.length() - 5; i++) {\n        if(str.substring(i, i + 5).equals(\"bread\")) {\n            first = i;\n            break;\n        }\n    }\n                                \n    for(int i = str.length() - 5; i >= 0; i--) {\n        if(str.substring(i, i + 5).equals(\"bread\")) {\n            last = i;\n            break;\n        }\n    }\n                                                          \n    if(first != -1 && last != -1 && first != last)\n        return str.substring(first + 5, last);\n                                                                    \n    return \"\";\n}\n"}, "sameStarChar": {"id": "p194491", "code": "/* Returns true if for every '*' (star) in the string, if there are chars \n * both immediately before and after the star, they are the same.\n */\npublic boolean sameStarChar(String str) {\n    for(int i = 1; i < str.length() - 1; i++) {\n        if(str.charAt(i) == '*' && str.charAt(i - 1) != str.charAt(i + 1))\n            return false;\n    }\n                \n    return true;\n}\n"}, "oneTwo": {"id": "p122943"}, "zipZap": {"id": "p180759", "code": "/* Look for patterns like \"zip\" and \"zap\" in the string -- length-3, starting \n * with 'z' and ending with 'p'. Return a string where for all such words, \n * the middle letter is gone, so \"zipXzap\" yields \"zpXzp\".\n */\npublic String zipZap(String str) {\n    char[] arr = new char[str.length()];\n    int count = 0;\n      \n    int i = 0;\n    while(i < str.length()) {\n        if(i < str.length() - 2 && str.charAt(i) == 'z' && \n            str.charAt(i + 2) == 'p') {\n            arr[count] = 'z';\n            count++;\n            arr[count] = 'p';\n            count++;\n            i += 3;\n        } else {\n            arr[count] = str.charAt(i);\n            count++;\n            i++;\n        }\n    }\n                                                                          \n    return new String(arr, 0, count);  \n}\n"}, "starOut": {"id": "p139564", "code": "/* Return a version of the given string, where for every star (*) in the \n * string the star and the chars immediately to its left and right are gone. \n * So \"ab*cd\" yields \"ad\" and \"ab**cd\" also yields \"ad\".\n */\npublic String starOut(String str) {\n    if(str.length() < 1)\n        return \"\";\n        \n    if(str.length() == 1) {\n        if(str.charAt(0) == '*')\n            return \"\";\n        else\n            return str;\n    }\n                                    \n    char[] arr = new char[str.length()];\n    int count = 0;\n                                            \n                                                \n    if(str.charAt(0) != '*' && str.charAt(1) != '*') {\n        arr[count] = str.charAt(0);\n        count++;\n    }\n                                                              \n    for(int i = 1; i < str.length() - 1; i++) {\n        if(str.charAt(i-1)!='*' && str.charAt(i) != '*' && \n            str.charAt(i+1) != '*') {\n            arr[count] = str.charAt(i);\n            count++;\n        }\n    }\n                                                                                        \n    if(str.charAt(str.length()-1) != '*' && \n        str.charAt(str.length()-2) != '*') {\n        arr[count] = str.charAt(str.length() - 1);\n        count++;\n    }\n                                                                                                      \n    return new String(arr, 0, count);\n}\n"}, "plusOut": {"id": "p170829", "code": "/* Given a string and a non-empty word string, return a version of the \n * original String where all chars have been replaced by pluses (\"+\"), except \n * for appearances of the word string which are preserved unchanged.\n */\npublic String plusOut(String str, String word) {\n    StringBuffer result = new StringBuffer();\n    int i = 0;\n      \n    while(i < str.length()) {\n        if(i <= str.length() - word.length() && \n            str.substring(i, i + word.length()).equals(word)) {\n            result.append(word);\n            i += word.length();\n        } else {\n            result.append(\"+\");\n            i++;\n        }\n    }\n \n    return result.toString();\n}\n"}, "wordEnds": {"id": "p147538", "code": "/* Given a string and a non-empty word string, return a string made of each \n * char just before and just after every appearance of the word in the \n * string. Ignore cases where there is no char before or after the word, and \n * a char may be included twice if it is between two words.\n */\npublic String wordEnds(String str, String word) {\n    StringBuffer result = new StringBuffer();\n    int i = 0;\n      \n    if(str.length() >= word.length() + 1 && \n        str.substring(0, word.length()).equals(word)) {\n        i = word.length() - 1;\n        result.append(str.charAt(i + 1));\n    }\n                        \n    while(i < str.length() - word.length()) {\n        if(str.substring(i + 1, i + 1 + word.length()).equals(word)) {\n            result.append(str.charAt(i));\n            i = i + word.length();\n            if(i < str.length() - 1) {\n                result.append(str.charAt(i + 1));\n            }\n        } else {\n            i++;\n        }\n    }\n                                                                                \n    return result.toString();\n}\n"}, "countYZ": {"id": "p199171", "code": "/* Given a string, count the number of words ending in 'y' or 'z' -- so the \n * 'y' in \"heavy\" and the 'z' in \"fez\" count, but not the 'y' in \"yellow\" \n * (not case sensitive). We'll say that a y or z is at the end of a word if \n * there is not an alphabetic letter immediately following it.\n */\npublic int countYZ(String str) {\n    if(str.length() == 0)\n        return 0;\n        \n    int count = 0;  \n            \n    for(int i = 0; i <= str.length() - 2; i++) {\n        if((Character.toLowerCase(str.charAt(i)) == 'y' || \n            Character.toLowerCase(str.charAt(i)) == 'z') &&\n            !Character.isLetter(str.charAt(i+1)))\n            count++;\n    }\n                                        \n    if(Character.toLowerCase(str.charAt(str.length() - 1)) == 'y' ||\n        Character.toLowerCase(str.charAt(str.length() - 1)) == 'z')\n        count++;\n                                                    \n    return count;\n}\n"}, "withoutString": {"id": "p192570", "code": "/* Given two strings, base and remove, return a version of the base string \n * where all instances of the remove string have been removed (not case \n * sensitive). You may assume that the remove string is length 1 or more. \n * Remove only non-overlapping instances, so with \"xxx\" removing \"xx\" \n * leaves \"x\".\n */\npublic String withoutString(String base, String remove) {\n    char[] arr = new char[base.length()];\n    int count = 0;\n    int i = 0;\n        \n    while(i <= base.length() - remove.length()) {\n        if(base.substring(i, i + remove.length()).toLowerCase().equals(\n            remove.toLowerCase())) {\n            i += remove.length();\n        } else {\n            arr[count] = base.charAt(i);\n            count++;\n            i++;\n        }\n    }\n                                                        \n    while(i < base.length()) {\n        arr[count] = base.charAt(i);\n        count++;\n        i++;\n    }\n                                                                          \n    return new String(arr, 0, count);\n}\n"}, "equalIsNot": {"id": "p141736", "code": "/* Given a string, return true if the number of appearances of \"is\" anywhere \n * in the string is equal to the number of appearances of \"not\" anywhere in \n * the string (case sensitive).\n */\npublic boolean equalIsNot(String str) {\n    int is = 0;\n    int not = 0;\n      \n    for(int i = 0; i <= str.length() - 3; i++) {\n        if(str.substring(i, i + 2).equals(\"is\")) {\n            is++;\n        } else if(str.substring(i, i + 3).equals(\"not\")) {\n            not++;\n        }\n    }\n                                    \n    if(str.length() >= 2 && str.substring(str.length() - 2).equals(\"is\"))\n        is++;\n                                              \n    return is == not;\n}\n"}, "gHappy": {"id": "p198664", "code": "/* We'll say that a lowercase 'g' in a string is \"happy\" if there is another \n * 'g' immediately to its left or right. Return true if all the g's in the \n * given string are happy.\n */\npublic boolean gHappy(String str) {\n    if(str.length() == 1 && str.charAt(0) == 'g')\n        return false;\n          \n    if(str.length() >= 2 &&\n        (str.charAt(0) == 'g' && str.charAt(1) != 'g' ||\n        str.charAt(str.length()-1) == 'g' && \n        str.charAt(str.length()-2) != 'g'))\n        return false;\n                          \n    for(int i = 1; i <= str.length() - 2; i++) {\n        if(str.charAt(i) == 'g' && str.charAt(i-1) != 'g' && \n            str.charAt(i+1) != 'g')\n            return false;\n    }\n                                          \n    return true;\n}\n\n"}, "countTriple": {"id": "p195714", "code": "/* We'll say that a \"triple\" in a string is a char appearing three times in a \n * row. Return the number of triples in the given string. The triples may \n * overlap.\n */\npublic int countTriple(String str) {\n    int count = 0;\n    \n    for(int i = 0; i <= str.length() - 3; i++) {\n        if(str.charAt(i) == str.charAt(i+1) && \n            str.charAt(i) == str.charAt(i+2))\n            count++;\n    }\n                    \n    return count;\n}\n"}, "sumDigits": {"id": "p163932", "code": "/* Given a non-negative int n, return the sum of its digits recursively \n * (no loops).\n */\npublic int sumDigits(int n) {\n    if(n == 0)\n        return 0;\n          \n    return n % 10 + sumDigits(n / 10);\n}\n"}, "sameEnds": {"id": "p134300", "code": "/* Given a string, return the longest substring that appears at both the \n * beginning and end of the string without overlapping. For example, \n * sameEnds(\"abXab\") is \"ab\".\n */\npublic String sameEnds(String string) {\n    int start = (int) Math.ceil((double) string.length() / 2);\n    int end = string.length() / 2;\n      \n    for(int i = 0; i < string.length() / 2; i++) {\n        if(string.substring(0, end).equals(string.substring(start))) {\n            return string.substring(0, end);\n        } else {\n            start++;\n            end--;\n        }\n    }\n                                          \n    return \"\";\n}\n"}, "mirrorEnds": {"id": "p139411", "code": "/* Given a string, look for a mirror image (backwards) string at both the \n * beginning and end of the given string. In other words, zero or more \n * characters at the very begining of the given string, and at the very end \n * of the string in reverse order (possibly overlapping). For example, the \n * string \"abXYZba\" has the mirror end \"ab\".\n */\npublic String mirrorEnds(String string) {\n    StringBuilder result = new StringBuilder();\n    \n    for(int i = 0; i < string.length(); i++) {\n        if(string.charAt(i) == string.charAt(string.length() - i - 1))\n            result.append(string.charAt(i));\n        else\n            break;\n    }\n                              \n    return result.toString();\n}\n"}, "maxBlock": {"id": "p179479", "code": "/* Given a string, return the length of the largest \"block\" in the string. \n * A block is a run of adjacent chars that are the same.\n */\npublic int maxBlock(String str) {\n    if(str.length() == 0)\n        return 0;\n          \n    int largest = 0;\n    int current = 1;\n                \n    for(int i = 1; i < str.length(); i++) {\n        if(str.charAt(i) != str.charAt(i-1)) {\n            if(current > largest)\n                largest = current;\n            current = 1;\n        } else {\n            current++;\n        }\n    }\n                                                            \n    return Math.max(largest, current);\n}\n"}, "sumNumbers": {"id": "p121193", "code": "/* Given a string, return the sum of the numbers appearing in the string, \n * ignoring all other characters. A number is a series of 1 or more digit \n * chars in a row.\n */\npublic int sumNumbers(String str) {\n    int sum = 0;\n    int i = 0;\n    int begin;\n    int end;\n          \n    while(i < str.length() && !Character.isDigit(str.charAt(i)))\n        i++;\n                    \n    begin = i;\n    end = i;\n                          \n    while(i < str.length()) {\n        if(!Character.isDigit(str.charAt(i))) {\n            sum += Integer.parseInt(str.substring(begin, end));\n            while(i < str.length() && !Character.isDigit(str.charAt(i)))\n                i++;\n                                                            \n            begin = i;\n            end = i;\n        } else {\n            end++;\n            i++;\n        }\n    }\n                                                                                                \n    if(end > begin)\n        sum += Integer.parseInt(str.substring(begin, end));\n                                                                                                        \n    return sum;\n}\n"}, "notReplace": {"id": "p154137", "code": "/* Given a string, return a string where every appearance of the lowercase \n * word \"is\" has been replaced with \"is not\". The word \"is\" should not be \n * immediately preceeded or followed by a letter -- so for example the \"is\" \n * in \"this\" does not count.\n */\npublic String notReplace(String str) {\n    if(str.equals(\"is\"))\n        return \"is not\";\n          \n    StringBuilder result = new StringBuilder();\n    int i = 0;\n                  \n    if(str.length() >= 3 && str.substring(0,2).equals(\"is\") &&\n        !Character.isLetter(str.charAt(2))) {\n        result.append(\"is not\");\n        i = 2;\n    }\n                                    \n    while(i < str.length()) {\n        if(!Character.isLetter(str.charAt(i))) {\n            result.append(str.charAt(i));\n            i++;\n        } else if(i >= 1 && i <= str.length()-3 && \n            !Character.isLetter(str.charAt(i-1)) &&\n            str.substring(i,i+2).equals(\"is\") &&\n            !Character.isLetter(str.charAt(i+2))) {\n            result.append(\"is not\");\n            i += 2;\n        } else if(i >= 1 && !Character.isLetter(str.charAt(i-1)) &&\n            str.substring(i).equals(\"is\")) {\n            result.append(\"is not\");\n            i += 2;\n        } else {\n            result.append(str.charAt(i));\n            i++;\n        }\n    }\n \n    return result.toString();\n}\n"}, "countEvens": {"id": "p162010", "code": "/* Return the number of even ints in the given array.\n */\npublic int countEvens(int[] nums) {\n    int count = 0;\n    \n    for(int i = 0; i < nums.length; i++) {\n        if(nums[i] % 2 == 0)\n            count++;\n    }\n                    \n    return count;\n}\n"}, "bigDiff": {"id": "p196640", "code": "/* Given an array length 1 or more of ints, return the difference between the \n * largest and smallest values in the array.\n */\npublic int bigDiff(int[] nums) {\n    int min = nums[0];\n    int max = nums[0];\n      \n    for(int i = 1; i < nums.length; i++) {\n        min = Math.min(min, nums[i]);\n        max = Math.max(max, nums[i]);\n    }\n                    \n    return max - min;\n}\n"}, "centeredAverage": {"id": "p136585", "code": "/* Return the \"centered\" average of an array of ints, which we'll say is the \n * mean average of the values, except ignoring the largest and smallest \n * values in the array. If there are multiple copies of the smallest value, \n * ignore just one copy, and likewise for the largest value. Use int division \n * to produce the final average. You may assume that the array is length 3 \n * or more.\n */\npublic int centeredAverage(int[] nums) {\n    int sum = 0;\n    int min = nums[0];\n    int max = nums[0];\n         \n    for(int i = 0; i < nums.length; i++) {\n        sum += nums[i];\n        min = Math.min(min, nums[i]);\n        max = Math.max(max, nums[i]);\n    }\n                           \n    return (sum - min - max) / (nums.length - 2);\n}\n"}, "sum13": {"id": "p127384", "code": "/* Return the sum of the numbers in the array, returning 0 for an empty \n * array. Except the number 13 is very unlucky, so it does not count and \n * numbers that come immediately after a 13 also do not count.\n */\npublic int sum13(int[] nums) {\n    int sum = 0;\n    int i = 0;\n      \n    while(i < nums.length) {\n        if(nums[i] == 13) {\n            i += 2;\n        } else {\n            sum += nums[i];\n            i++;\n        }\n    }\n                                          \n    return sum;\n}\n"}, "sum67": {"id": "p111327", "code": "/* Return the sum of the numbers in the array, except ignore sections of \n * numbers starting with a 6 and extending to the next 7 (every 6 will be \n * followed by at least one 7). Return 0 for no numbers.\n */\npublic int sum67(int[] nums) {\n    int sum = 0;\n    boolean inRange = false;\n      \n    for(int i = 0; i < nums.length; i++) {\n        if(nums[i] == 6)\n            inRange = true;\n\n        if(!inRange)\n            sum += nums[i];\n                                        \n        if(inRange && nums[i] == 7)\n            inRange = false;\n                                                        \n    }\n                                                            \n    return sum;\n}\n"}, "has22": {"id": "p121853", "code": "/* Given an array of ints, return true if the array contains a 2 next to a 2 \n * somewhere.\n */\npublic boolean has22(int[] nums) {\n    for(int i = 0; i < nums.length - 1; i++) {\n        if(nums[i] == 2 && nums[i + 1] == 2)\n            return true;\n    }\n                \n    return false;\n}\n"}, "lucky13": {"id": "p194525", "code": "/* Given an array of ints, return true if the array contains no 1's and \n * no 3's.\n */\npublic boolean lucky13(int[] nums) {\n    for(int i = 0; i < nums.length; i++) {\n        if(nums[i] == 1 || nums[i] == 3)\n            return false;\n    }\n                \n    return true;\n}\n"}, "sum28": {"id": "p199612", "code": "/* Given an array of ints, return true if the sum of all the 2's in the array \n * is exactly 8.\n */\npublic boolean sum28(int[] nums) {\n    int sum = 0;\n    \n    for(int i = 0; i < nums.length; i++) {\n        if(nums[i] == 2)\n            sum += nums[i];\n    }\n                    \n    return sum == 8;\n}\n"}, "more14": {"id": "p104627", "code": "/* Given an array of ints, return true if the number of 1's is greater than \n * the number of 4's\n */\npublic boolean more14(int[] nums) {\n    int count1 = 0;\n    int count4 = 0;\n      \n    for(int i = 0; i < nums.length; i++) {\n        if(nums[i] == 1)\n            count1++;\n                        \n        if(nums[i] == 4)\n            count4++;\n    }\n                                      \n    return count1 > count4;\n}\n"}, "fizzArray": {"id": "p180920", "code": "/* Given a number n, create and return a new int array of length n, \n * containing the numbers 0, 1, 2, ... n-1. The given n may be 0, in which \n * case just return a length 0 array. You do not need a separate if-statement \n * for the length-0 case; the for-loop should naturally execute 0 times in \n * that case, so it just works.\n */\npublic int[] fizzArray(int n) {\n    int[] arr = new int[n];\n    \n    for(int i = 0; i < n; i++)\n        arr[i] = i;\n              \n    return arr;\n}\n"}, "only14": {"id": "p186672", "code": "/* Given an array of ints, return true if every element is a 1 or a 4.\n */\npublic boolean only14(int[] nums) {\n    for(int i = 0; i < nums.length; i++) {\n        if(nums[i] != 1 && nums[i] != 4)\n            return false;\n    }\n                \n    return true;\n}\n"}, "fizzArray2": {"id": "p178353", "code": "/* Given a number n, create and return a new string array of length n, \n * containing the strings \"0\", \"1\" \"2\" .. through n-1. N may be 0, in which \n * case just return a length 0 array.\n */\npublic String[] fizzArray2(int n) {\n    String[] arr = new String[n];\n    \n    for(int i = 0; i < n; i++)\n        arr[i] = String.valueOf(i);\n              \n    return arr;\n}\n"}, "no14": {"id": "p136648", "code": "/* Given an array of ints, return true if it contains no 1's or it contains \n * no 4's.\n */\npublic boolean no14(int[] nums) {\n    boolean has1 = false;\n    boolean has4 = false;\n    for(int i = 0; i < nums.length; i++) {\n        if(nums[i] == 1)\n            has1 = true;\n                      \n        if(nums[i] == 4)\n            has4 = true;\n    }\n                                    \n    return !has1 || !has4;\n}\n"}, "isEverywhere": {"id": "p110222", "code": "/* We'll say that a value is \"everywhere\" in an array if for every pair of \n * adjacent elements in the array, at least one of the pair is that value. \n * Return true if the given value is everywhere in the array.\n */\npublic boolean isEverywhere(int[] nums, int val) {\n    for(int i = 0; i < nums.length - 1; i++) {\n        if(nums[i] != val && nums[i + 1] != val)\n            return false;\n    }\n                \n    return true;\n}\n"}, "either24": {"id": "p191878", "code": "/* Given an array of ints, return true if the array contains a 2 next to \n * a 2 or a 4 next to a 4, but not both.\n */\npublic boolean either24(int[] nums) {\n    boolean has22 = false;\n    boolean has44 = false;\n      \n    for(int i = 0; i < nums.length - 1; i++) {\n        if(nums[i] == 2 && nums[i+1] == 2)\n            has22 = true;\n                        \n        if(nums[i] == 4 && nums[i+1] == 4)\n            has44 = true;\n    }\n                                      \n    return has22 != has44;\n}\n"}, "matchUp": {"id": "p139677", "code": "/* Given 2 arrays that are the same length containing strings, compare the \n * 1st string in one array to the 1st string in the other array, the 2nd to \n * the 2nd and so on. Count the number of times that the 2 strings are \n * non-empty and start with the same char. The strings may be any length, \n * including 0.\n */\npublic int matchUp(String[] a, String[] b) {\n    int count = 0;\n    \n    for(int i = 0; i < a.length; i++) {\n        if(a[i].length() > 0 && b[i].length() > 0 && \n            a[i].charAt(0) == b[i].charAt(0))\n            count++;\n    }\n                          \n    return count;\n}\n"}, "has77": {"id": "p168357", "code": "/* Given an array of ints, return true if the array contains two 7's next \n * to each other, or there are two 7's separated by one element, such as \n * with {7, 1, 7}.\n */\npublic boolean has77(int[] nums) {\n    for(int i = 0; i < nums.length - 1; i++) {\n        if(nums[i] == 7 && nums[i+1] == 7)\n            return true;\n                  \n        if(i <= nums.length - 3 && nums[i] == 7 && nums[i+2] == 7)\n            return true;\n    }\n                                \n    return false;\n}\n"}, "has12": {"id": "p169260", "code": "/* Given an array of ints, return true if there is a 1 in the array with a \n * 2 somewhere later in the array.\n */\npublic boolean has12(int[] nums) {\n    boolean found1 = false;\n    \n    for(int i = 0; i < nums.length; i++) {\n        if(nums[i] == 1)\n            found1 = true;\n                    \n        if(found1 && nums[i] == 2)\n            return true;\n    }\n                                  \n    return false;  \n}\n"}, "modThree": {"id": "p159979", "code": "/* Given an array of ints, return true if the array contains either 3 even \n * or 3 odd values all next to each other.\n */\npublic boolean modThree(int[] nums) {\n    if(nums.length < 3)\n        return false;\n          \n    for(int i = 0; i <= nums.length - 3; i++) {\n        if(nums[i] % 2 == nums[i+1] % 2 && nums[i] % 2 == nums[i+2] % 2)\n            return true;\n    }\n                          \n    return false;\n}\n"}, "haveThree": {"id": "p109783", "code": "/* Given an array of ints, return true if the value 3 appears in the array \n * exactly 3 times, and no 3's are next to each other.\n */\npublic boolean haveThree(int[] nums) {\n    int count = 0;\n    \n    if(nums.length >= 1 && nums[0] == 3)\n        count++;\n\n    for(int i = 1; i < nums.length; i++) {\n        if(nums[i - 1] == 3 && nums[i] == 3)\n            return false;\n                            \n        if(nums[i] == 3)\n            count++;\n    }\n                                          \n    return count == 3;\n}\n"}, "twoTwo": {"id": "p102145", "code": "/* Given an array of ints, return true if every 2 that appears in the array \n * is next to another 2.\n */\npublic boolean twoTwo(int[] nums) {\n    if(nums.length == 1 && nums[0] == 2)\n        return false;\n          \n    if(nums.length >= 2 && ((nums[0] == 2 && nums[1] != 2) ||\n        (nums[nums.length-1] == 2 && nums[nums.length-2] != 2)))\n        return false;\n                            \n    for(int i = 1; i <= nums.length - 2; i++) {\n        if(nums[i] == 2 && nums[i-1] != 2 && nums[i+1] != 2)\n            return false;\n    }\n                                            \n    return true;\n}\n"}, "tripleUp": {"id": "p137874", "code": "/* Return true if the array contains, somewhere, three increasing adjacent \n * numbers like .... 4, 5, 6, ... or 23, 24, 25.\n */\npublic boolean tripleUp(int[] nums) {\n    for(int i = 0; i <= nums.length - 3; i++) {\n        if(nums[i] + 1 == nums[i+1] && nums[i+1] + 1 == nums[i+2])\n            return true;\n    }\n                \n    return false;\n}\n"}, "fizzArray3": {"id": "p142539", "code": "/* Given start and end numbers, return a new array containing the sequence of \n * integers from start up to but not including end, so start=5 and end=10 \n * yields {5, 6, 7, 8, 9}. The end number will be greater or equal to the \n * start number. Note that a length-0 array is valid.\n */\npublic int[] fizzArray3(int start, int end) {\n    int[] arr = new int[end - start];\n    \n    for(int i = start; i < end; i++)\n        arr[i - start] = i;\n              \n    return arr;\n}\n"}, "shiftLeft": {"id": "p105031", "code": "/* Return an array that is \"left shifted\" by one -- so {6, 2, 5, 3} returns \n * {2, 5, 3, 6}. You may modify and return the given array, or return a new \n * array.\n */\npublic int[] shiftLeft(int[] nums) {\n    if(nums.length < 1)\n        return nums;\n          \n    int first = nums[0];\n              \n    for(int i = 1; i < nums.length; i++)\n        nums[i - 1] = nums[i];\n                        \n    nums[nums.length - 1] = first;\n                            \n    return nums;\n}\n"}, "tenRun": {"id": "p199484", "code": "/* For each multiple of 10 in the given array, change all the values \n * following it to be that multiple of 10, until encountering another \n * multiple of 10. So {2, 10, 3, 4, 20, 5} yields {2, 10, 10, 10, 20, 20}.\n */\npublic int[] tenRun(int[] nums) {\n    int current;\n    int i = 0;\n      \n    while(i < nums.length && nums[i] % 10 != 0)\n        i++;\n                \n    if(i >= nums.length)\n        return nums;\n                          \n    current = nums[i]; \n    i++;\n                                \n    while(i < nums.length) {\n        if(nums[i] % 10 == 0)\n            current = nums[i];\n        else\n            nums[i] = current;\n        i++;\n    }\n                                                              \n    return nums; \n}\n"}, "pre4": {"id": "p100246", "code": "/* Given a non-empty array of ints, return a new array containing the \n * elements from the original array that come before the first 4 in the \n * original array. The original array will contain at least one 4. Note that \n * it is valid in java to create an array of length 0.\n */\npublic int[] pre4(int[] nums) {\n    int i = 0;\n    \n    while(nums[i] != 4)\n        i++;\n              \n    int[] arr = new int[i];\n                  \n    for(int j = 0; j < i; j++)\n        arr[j] = nums[j];\n                            \n    return arr;\n}\n"}, "post4": {"id": "p164144", "code": "/* Given a non-empty array of ints, return a new array containing the \n * elements from the original array that come after the last 4 in the \n * original array. The original array will contain at least one 4. Note that \n * it is valid in java to create an array of length 0.\n */\npublic int[] post4(int[] nums) {\n    int i = nums.length - 1;\n    \n    while(nums[i] != 4)\n        i--;\n              \n    int[] arr = new int[nums.length - i - 1];\n                  \n    for(int j = 0; j < arr.length; j++)\n        arr[j] = nums[i + j + 1];\n                          \n    return arr;\n}\n"}, "notAlone": {"id": "p169506", "code": "/* We'll say that an element in an array is \"alone\" if there are values \n * before and after it, and those values are different from it. Return a \n * version of the given array where every instance of the given value which \n * is alone is replaced by whichever value to its left or right is larger.\n */\npublic int[] notAlone(int[] nums, int val) {\n    int[] arr = new int[nums.length];\n    \n    if(nums.length >= 1) {\n        arr[0] = nums[0];\n        arr[arr.length-1] = nums[nums.length-1];\n    }\n                  \n    for(int i = 1; i <= nums.length - 2; i++) {\n        if(nums[i] == val && nums[i] != nums[i-1] && nums[i] != nums[i+1])\n            arr[i] = Math.max(nums[i-1], nums[i+1]);\n        else\n            arr[i] = nums[i];\n    }\n                                            \n    return arr;\n}\n"}, "zeroFront": {"id": "p193753", "code": "/* Return an array that contains the exact same numbers as the given array, \n * but rearranged so that all the zeros are grouped at the start of the array. \n * The order of the non-zero numbers does not matter. So {1, 0, 0, 1} becomes \n * {0 ,0, 1, 1}. You may modify and return the given array or make a new array.\n */\npublic int[] zeroFront(int[] nums) {\n    if(nums.length == 0)\n        return nums;\n          \n    int i = 0;\n              \n    while(nums[i] == 0)\n        i++;\n                        \n    for(int j = i + 1; j < nums.length; j++) {\n        if(nums[j] == 0) {\n            int temp = nums[i];\n            nums[i] = nums[j];\n            nums[j] = temp;\n            i++;\n        }\n    }\n                                                              \n    return nums;\n}\n"}, "withoutTen": {"id": "p196976", "code": "/* Return a version of the given array where all the 10's have been removed. \n * The remaining elements should shift left towards the start of the array as \n * needed, and the empty spaces a the end of the array should be 0. So \n * {1, 10, 10, 2} yields {1, 2, 0, 0}. You may modify and return the given \n * array or make a new array.\n */\npublic int[] withoutTen(int[] nums) {\n    int i = 0;\n    \n    while(i < nums.length && nums[i] != 10)\n        i++;\n              \n    for(int j = i + 1; j < nums.length; j++) {\n        if(nums[j] != 10) {\n            nums[i] = nums[j];\n            nums[j] = 10;\n            i++;\n        }\n    }\n                                              \n    for( ; i < nums.length; i++)\n        nums[i] = 0;\n                                                      \n    return nums;\n}\n"}, "zeroMax": {"id": "p187050", "code": "/* Return a version of the given array where each zero value in the array is \n * replaced by the largest odd value to the right of the zero in the array. If \n * there is no odd value to the right of the zero, leave the zero as a zero.\n */\npublic int[] zeroMax(int[] nums) {\n    int i = nums.length - 1;\n    \n    while(i >= 0 && nums[i] % 2 == 0)\n        i--;\n              \n    for(int j = i - 1; j >= 0; j--) {\n        if(nums[j] == 0)\n            nums[j] = nums[i];\n                              \n        if(nums[j] % 2 == 1 && nums[j] > nums[i])\n            i = j;\n    }\n                                            \n    return nums;\n}\n"}, "evenOdd": {"id": "p105771", "code": "/* Return an array that contains the exact same numbers as the given array, \n * but rearranged so that all the even numbers come before all the odd \n * numbers. Other than that, the numbers can be in any order. You may modify \n * and return the given array, or make a new array.\n */\npublic int[] evenOdd(int[] nums) {\n    int i = 0;\n    \n    while(i < nums.length && nums[i] % 2 == 0)\n        i++;\n              \n    for(int j = i + 1; j < nums.length; j++) {\n        if(nums[j] % 2 == 0) {\n            int temp = nums[i];\n            nums[i] = nums[j];\n            nums[j] = temp;\n            i++;\n        }\n    }\n                                                    \n    return nums;\n}\n"}, "fizzBuzz": {"id": "p153059", "code": "/* This is slightly more difficult version of the famous FizzBuzz problem \n * which is sometimes given as a first problem for job interviews. Consider \n * the series of numbers beginning at start and running up to but not \n * including end, so for example start=1 and end=5 gives the series \n * 1, 2, 3, 4. Return a new String[] array containing the string form of \n * these numbers, except for multiples of 3, use \"Fizz\" instead of the \n * number, for multiples of 5 use \"Buzz\", and for multiples of both 3 and 5 \n * use \"FizzBuzz\". In Java, String.valueOf(xxx) will make the String form of \n * an int or other type. This version is a little more complicated than the \n * usual version since you have to allocate and index into an array instead \n * of just printing, and we vary the start/end instead of just always doing \n * 1..100.\n */\npublic String[] fizzBuzz(int start, int end) {\n    String[] arr = new String[end - start];\n    \n    for(int i = start; i < end; i++) {\n        if(i % 15 == 0) {\n            arr[i - start] = \"FizzBuzz\";\n        } else if(i % 3 == 0) {\n            arr[i - start] = \"Fizz\";\n        } else if(i % 5 == 0) {\n            arr[i - start] = \"Buzz\";\n        } else {\n            arr[i - start] = String.valueOf(i);\n        }\n    }\n                                                      \n    return arr;\n}\n"}, "maxSpan": {"id": "p189576", "code": "/* Consider the leftmost and righmost appearances of some value in an array. \n * We'll say that the \"span\" is the number of elements between the two \n * inclusive. A single value has a span of 1. Returns the largest span found \n * in the given array. (Efficiency is not a priority.)\n */\npublic int maxSpan(int[] nums) {\n    int max = 0;\n    \n    for(int i = 0; i < nums.length; i++) {\n        int j = nums.length - 1;\n              \n        while(nums[i] != nums[j])\n            j--;\n                              \n        int span = j - i + 1;\n                                      \n        if(span > max)\n            max = span;\n    }\n                                                    \n    return max;\n}\n"}, "fix34": {"id": "p159339", "code": "/* Return an array that contains exactly the same numbers as the given array, \n * but rearranged so that every 3 is immediately followed by a 4. Do not move \n * the 3's, but every other number may move. The array contains the same \n * number of 3's and 4's, every 3 has a number after it that is not a 3 or 4, \n * and a 3 appears in the array before any 4.\n */\npublic int[] fix34(int[] nums) {\n    int i = 0;\n    \n    while(i < nums.length && nums[i] != 3)\n        i++;\n              \n    int j = i + 1;\n                  \n    while(j < nums.length && nums[j] != 4)\n        j++;\n                            \n    while(i < nums.length) {\n        if(nums[i] == 3) {\n            int temp = nums[i+1];\n            nums[i+1] = nums[j];\n            nums[j] = temp;\n                                                          \n            while(j < nums.length && nums[j] != 4)\n                j++;\n        }\n        i++;\n    }\n\n    return nums;\n}\n"}, "fix45": {"id": "p125819", "code": "/* Return an array that contains exactly the same numbers as the given array, \n * but rearranged so that every 4 is immediately followed by a 5. Do not move \n * the 4's, but every other number may move. The array contains the same \n * number of 4's and 5's, and every 4 has a number after it that is not a 4. \n * In this version, 5's may appear anywhere in the original array.\n */\npublic int[] fix45(int[] nums) {\n    int i = 0;\n    int j = 0;\n        \n    while(j < nums.length && nums[j] != 5)\n        j++;\n                  \n    while(i < nums.length) {\n        if(nums[i] == 4) {\n            int temp = nums[i+1];\n            nums[i+1] = nums[j];\n            nums[j] = temp;\n                                                \n            while((j < nums.length && nums[j] != 5) || j == i + 1)\n                j++;\n        }\n        i++;\n    }\n                                                                          \n    return nums;\n}\n"}, "canBalance": {"id": "p158767", "code": "/* Given a non-empty array, return true if there is a place to split the \n * array so that the sum of the numbers on one side is equal to the sum of \n * the numbers on the other side.\n */\npublic boolean canBalance(int[] nums) {\n    int first = 0;\n    int second = 0;\n      \n    for(int i = 0; i < nums.length; i++)\n        second += nums[i];\n              \n    for(int i = 0; i <= nums.length - 2; i++) {\n        first += nums[i];\n        second -= nums[i];\n                            \n        if(first == second)\n            return true;\n    }\n                                          \n    return false;\n}\n"}, "linearIn": {"id": "p134022", "code": "/* Given two arrays of ints sorted in increasing order, outer and inner, \n * return true if all of the numbers in inner appear in outer. The best \n * solution makes only a single \"linear\" pass of both arrays, taking \n * advantage of the fact that both arrays are already in sorted order.\n */\npublic boolean linearIn(int[] outer, int[] inner) {\n    int i = 0;\n    int j = 0;\n      \n    while(i < inner.length && j < outer.length) {\n        if(inner[i] > outer[j]) {\n            j++;\n        } else if(inner[i] < outer[j]) {\n            return false;\n        } else {\n            i++;\n        }\n    }\n                                              \n    if(i != inner.length)\n        return false;\n                                                      \n    return true;\n}\n"}, "squareUp": {"id": "p155405", "code": "/* Given n>=0, create an array length n*n with the following pattern, shown \n * here for n=3 : {0, 0, 1,    0, 2, 1,    3, 2, 1}\n */\npublic int[] squareUp(int n) {\n    int[] arr = new int[n*n];\n    \n    if(n == 0)\n        return arr;\n              \n    for(int i = n - 1; i < arr.length; i += n) {\n        for(int j = i; j >= i - i / n; j--)\n            arr[j] = i - j + 1;\n    }\n                              \n    return arr;\n}\n"}, "seriesUp": {"id": "p104090", "code": "/* Given n>=0, create an array with the pattern \n * {1,    1, 2,    1, 2, 3,   ... 1, 2, 3 .. n} (spaces added to show the \n * grouping).\n */\npublic int[] seriesUp(int n) {\n    int[] arr = new int[n*(n+1)/2];\n    \n    int index = 0;\n        \n    for(int i = 1; i <= n; i++) {\n        for(int j = 0; j < i; j++) {\n            arr[index + j] = j + 1;\n        }\n        index += i;\n    }\n                                \n    return arr;\n}\n"}, "maxMirror": {"id": "p196409", "code": "/* We'll say that a \"mirror\" section in an array is a group of contiguous \n * elements such that somewhere in the array, the same group appears in \n * reverse order. For example, the largest mirror section in \n * {1, 2, 3, 8, 9, 3, 2, 1} is length 3 (the {1, 2, 3} part). Return the size \n * of the largest mirror section found in the given array.\n */\npublic int maxMirror(int[] nums) {\n    int max = 0;\n    \n    for(int i = 0; i < nums.length; i++) {\n        int count = 0;\n        for(int j = nums.length - 1; j >= 0 && i + count < nums.length; j--) {\n            if(nums[i + count] == nums[j]) {\n                count++;\n            } else {\n                max = Math.max(max, count);\n                count = 0;\n            }\n        }\n                                                                \n        max = Math.max(max, count);\n    }\n\n    return max;\n}\n\n// I think this version is easier to understand but it has 3 nested loops\n// instead of just 2.\n/*\npublic int maxMirror(int[] nums) {\n    int max = 0;\n    \n    for(int start = 0; start < nums.length; start++) {\n        for(int begin = nums.length - 1; begin >= 0; begin--) {\n            int size = 0;\n            int i = start;\n            int j = begin;\n                                  \n            while(i < nums.length && j >= 0 && nums[i] == nums[j]) {\n                size++;\n                i++;\n                j--;\n            }\n                                                                              \n            max = Math.max(max, size);\n        }\n    }\n                                                                                            \n    return max;\n}\n*/\n"}, "countClumps": {"id": "p193817", "code": "/* Say that a \"clump\" in an array is a series of 2 or more adjacent elements \n * of the same value. Return the number of clumps in the given array.\n */\npublic int countClumps(int[] nums) {\n    int count = 0;\n    int i = 0;\n      \n    while(i < nums.length) {\n        int val = nums[i];\n        i++;\n        int length = 1;\n        while(i < nums.length && nums[i] == val) {\n            i++;\n            length++;\n        }\n                                            \n        if(length > 1)\n            count++;\n    }\n                                                          \n    return count;\n}\n"}, "scoresIncreasing": {"id": "p146974", "code": "/* Given an array of scores, return true if each score is equal or greater \n * than the one before. The array will be length 2 or more.\n */\npublic boolean scoresIncreasing(int[] scores) {\n    for(int i = 1; i < scores.length; i++) {\n        if(scores[i] < scores[i-1])\n            return false;\n    }\n                \n    return true;\n}\n"}, "scores100": {"id": "p179487", "code": "/* Given an array of scores, return true if there are scores of 100 next to \n * each other in the array. The array length will be at least 2.\n */\npublic boolean scores100(int[] scores) {\n    for(int i = 0; i <= scores.length - 2; i++) {\n        if(scores[i] == 100 && scores[i+1] == 100)\n            return true;\n    }\n                \n    return false;\n}\n"}, "scoresClump": {"id": "p194530", "code": "/* Given an array of scores sorted in increasing order, return true if the \n * array contains 3 adjacent scores that differ from each other by at most 2, \n * such as with {3, 4, 5} or {3, 5, 5}.\n */\npublic boolean scoresClump(int[] scores) {\n    for(int i = 0; i <= scores.length - 3; i++) {\n        if(scores[i+2] - scores[i] <= 2)\n            return true;\n    }\n                \n    return false;\n}\n"}, "scoresAverage": {"id": "p123837", "code": "/* Given an array of scores, compute the int average of the first half and the \n * second half, and return whichever is larger. We'll say that the second half \n * begins at index length/2. The array length will be at least 2. To practice \n * decomposition, write a separate helper method <br>int average(int[] scores, \n * int start, int end) { which computes the average of the elements between \n * indexes start..end. Call your helper method twice to implement \n * scoresAverage().\n */\npublic int scoresAverage(int[] scores) {\n    int first = average(scores, 0, scores.length / 2);\n    int second = average(scores, scores.length / 2, scores.length);\n    return Math.max(first, second);\n}\n\npublic int average(int[] scores, int start, int end) {\n    int sum = 0;\n          \n    for(int i = start; i < end; i++)\n        sum += scores[i];\n\n    return sum / (end - start);\n}\n"}, "wordsCount": {"id": "p124620", "code": "/* Given an array of strings, return the count of the number of strings with \n * the given length.\n */\npublic int wordsCount(String[] words, int len) {\n    int count = 0;\n    \n    for(int i = 0; i < words.length; i++) {\n        if(words[i].length() == len)\n            count++;\n    }\n                    \n    return count;\n}\n"}, "wordsFront": {"id": "p183837", "code": "/* Given an array of strings, return a new array containing the first N \n * strings. N will be in the range 1..length.\n */\npublic String[] wordsFront(String[] words, int n) {\n    String[] arr = new String[n];\n    \n    for(int i = 0; i < arr.length; i++)\n        arr[i] = words[i];\n              \n    return arr;\n}\n"}, "wordsWithoutList": {"id": "p183407", "code": "/* Given an array of strings, return a new List (e.g. an ArrayList) where all \n * the strings of the given length are omitted. See wordsWithout() below \n * which is more difficult because it uses arrays.\n */\npublic List wordsWithoutList(String[] words, int len) {\n    ArrayList<String> list = new ArrayList<String>();\n    \n    for(int i = 0; i < words.length; i++) {\n        if(words[i].length() != len)\n            list.add(words[i]);\n    }\n                    \n    return list;\n}\n"}, "hasOne": {"id": "p191212", "code": "/* Given a positive int n, return true if it contains a 1 digit.\n */\npublic boolean hasOne(int n) {\n    while(n != 0) {\n        if(n % 10 == 1)\n            return true;\n                  \n        n /= 10;\n    }\n                          \n    return false;\n}\n"}, "dividesSelf": {"id": "p165941", "code": "/* We'll say that a positive int divides itself if every digit in the number \n * divides into the number evenly. So for example 128 divides itself since \n * 1, 2, and 8 all divide into 128 evenly. We'll say that 0 does not divide \n * into anything evenly, so no number with a 0 digit divides itself.\n */\npublic boolean dividesSelf(int n) {\n\n    for(int val = n; val != 0; val /= 10) {\n        int digit = val % 10;\n        if(digit == 0 || n % digit != 0)\n            return false;\n    }\n                      \n    return true;\n}\n"}, "copyEvens": {"id": "p134174", "code": "/* Given an array of positive ints, return a new array of length \"count\" \n * containing the first even numbers from the original array. The original \n * array will contain at least \"count\" even numbers.\n */\npublic int[] copyEvens(int[] nums, int count) {\n    int[] arr = new int[count];\n    int index = 0;\n      \n    for(int i = 0; index < count; i++) {\n        if(nums[i] % 2 == 0) {\n            arr[index] = nums[i];\n            index++;\n        }\n    }\n                                \n    return arr;\n}\n"}, "copyEndy": {"id": "p130124", "code": "/* We'll say that a positive int n is \"endy\" if it is in the range \n * 0..10 or 90..100 (inclusive). Given an array of positive ints, return a \n * new array of length \"count\" containing the first endy numbers from the \n * original array. Decompose out a separate isEndy(int n) method to test if a \n * number is endy. The original array will contain at least \"count\" endy \n * numbers.\n */\npublic int[] copyEndy(int[] nums, int count) {\n    int[] arr = new int[count];\n    int index = 0;\n      \n    for(int i = 0; index < count; i++) {\n        if(isEndy(nums[i])) {\n            arr[index] = nums[i];\n            index++;\n        }\n    }\n                                \n    return arr;\n}\n\npublic boolean isEndy(int n) {\n    return 0 <= n && n <= 10 || 90 <= n && n <= 100;\n}\n"}, "scoreUp": {"id": "p180365", "code": "/* The \"key\" array is an array containing the correct answers to an exam, \n * like {\"a\", \"a\", \"b\", \"b\"}. the \"answers\" array contains a student's \n * answers, with \"?\" representing a question left blank. The two arrays are \n * not empty and are the same length. Return the score for this array of \n * answers, giving +4 for each correct answer, -1 for each incorrect answer, \n * and +0 for each blank answer.\n */\npublic int scoreUp(String[] key, String[] answers) {\n    int score = 0;\n    \n    for(int i = 0; i < key.length; i++) {\n        if(key[i].charAt(0) == answers[i].charAt(0)) {\n            score += 4;\n        } else if(answers[i].charAt(0) != '?') {\n            score -= 1;\n        }\n    }\n                                  \n    return score;\n}\n"}, "wordsWithout": {"id": "p121236", "code": "/* Given an array of strings, return a new array without the strings that are \n * equal to the target string. One approach is to count the occurrences of the \n * target string, make a new array of the correct length, and then copy over \n * the correct strings.\n */\npublic String[] wordsWithout(String[] words, String target) {\n    int count = 0;\n    \n    for(int i = 0; i < words.length; i++) {\n        if(!words[i].equals(target))\n            count++;\n    }\n                    \n    String[] arr = new String[count];\n    int index = 0;\n                          \n    for(int i = 0; index < count; i++) {\n        if(!words[i].equals(target)) {\n            arr[index] = words[i];\n            index++;\n        }\n    }\n                                                    \n    return arr;\n}\n"}, "scoresSpecial": {"id": "p140485", "code": "/* Given two arrays, A and B, of non-negative int scores. A \"special\" score \n * is one which is a multiple of 10, such as 40 or 90. Return the sum of \n * largest special score in A and the largest special score in B. To practice \n * decomposition, write a separate helper method which finds the largest \n * special score in an array.\n */\npublic int scoresSpecial(int[] a, int[] b) {\n    return largestSpecial(a) + largestSpecial(b);\n}\n\npublic int largestSpecial(int[] a) {\n    int largest = 0;\n      \n    for(int i = 0; i < a.length; i++) {\n        if(a[i] % 10 == 0 && a[i] > largest)\n            largest = a[i];\n    }\n                      \n    return largest;\n}\n"}, "sumHeights": {"id": "p148138", "code": "/* We have an array of heights, representing the altitude along a walking \n * trail. Given start/end indexes into the array, return the sum of the \n * changes for a walk beginning at the start index and ending at the end \n * index. For example, with the heights {5, 3, 6, 7, 2} and start=2, end=4 \n * yields a sum of 1 + 5 = 6. The start end end index will both be valid \n * indexes into the array with start <= end.\n */\npublic int sumHeights(int[] heights, int start, int end) {\n    int sum = 0;\n    \n    for(int i = start; i < end; i++)\n        sum += Math.abs(heights[i] - heights[i+1]);\n              \n    return sum;\n}\n"}, "sumHeights2": {"id": "p157900", "code": "/* We have an array of heights, representing the altitude along a walking \n * trail. Given start/end indexes into the array, return the sum of the \n * changes for a walk beginning at the start index and ending at the end \n * index, however increases in height count double. For example, with the \n * heights {5, 3, 6, 7, 2} and start=2, end=4 yields a sum of 1*2 + 5 = 7. \n * The start end end index will both be valid indexes into the array with \n * start <= end.\n */\npublic int sumHeights2(int[] heights, int start, int end) {\n    int sum = 0;\n    \n    for(int i = start; i < end; i++) {\n        if(heights[i] < heights[i+1])\n            sum = sum + 2 * (heights[i+1] - heights[i]);\n        else\n            sum = sum + heights[i] - heights[i+1];\n    }\n                              \n    return sum;\n}\n"}, "bigHeights": {"id": "p197710", "code": "/* We have an array of heights, representing the altitude along a walking \n * trail. Given start/end indexes into the array, return the number of \"big\" \n * steps for a walk starting at the start index and ending at the end index. \n * We'll say that step is big if it is 5 or more up or down. The start end end \n * index will both be valid indexes into the array with start <= end.\n */\npublic int bigHeights(int[] heights, int start, int end) {\n    int count = 0;\n    \n    for(int i = start; i < end; i++) {\n        if(Math.abs(heights[i] - heights[i+1]) >= 5)\n            count++;\n    }\n                    \n    return count;\n}\n"}, "userCompare": {"id": "p143482", "code": "/* We have data for two users, A and B, each with a String name and an int id. \n * The goal is to order the users such as for sorting. Return -1 if A comes \n * before B, 1 if A comes after B, and 0 if they are the same. Order first by \n * the string names, and then by the id numbers if the names are the same.\n */\npublic int userCompare(String aName, int aId, String bName, int bId) {\n    if(aName.compareTo(bName) < 0) {\n        return -1;\n    } else if(aName.compareTo(bName) > 0) {\n        return 1;\n    } else if(aId < bId) {\n        return -1;\n    } else if(aId > bId) {\n        return 1;\n    }\n                            \n    return 0;\n}\n"}, "mergeTwo": {"id": "p139150", "code": "/* Start with two arrays of strings, A and B, each with its elements in \n * alphabetical order and without duplicates. Return a new array containing \n * the first N elements from the two arrays. The result array should be in \n * alphabetical order and without duplicates. A and B will both have a length \n * which is N or more. The best \"linear\" solution makes a single pass over A \n * and B, taking advantage of the fact that they are in alphabetical order, \n * copying elements directly to the new array.\n */\npublic String[] mergeTwo(String[] a, String[] b, int n) {\n    String[] arr = new String[n];\n    int aIndex = 0;\n    int bIndex = 0;\n        \n    for(int index = 0; index < n; index++) {\n        if(a[aIndex].compareTo(b[bIndex]) < 0) {\n            arr[index] = a[aIndex];\n            aIndex++;\n        } else if(a[aIndex].compareTo(b[bIndex]) > 0) {\n            arr[index] = b[bIndex];\n            bIndex++;\n        } else {\n            arr[index] = a[aIndex];\n            aIndex++;\n            bIndex++;\n        }\n    }\n                                                                        \n    return arr;\n}\n"}, "commonTwo": {"id": "p100369", "code": "/* Start with two arrays of strings, a and b, each in alphabetical order, \n * possibly with duplicates. Return the count of the number of strings which \n * appear in both arrays. The best \"linear\" solution makes a single pass over \n * both arrays, taking advantage of the fact that they are in alphabetical \n * order.\n */\npublic int commonTwo(String[] a, String[] b) {\n    int count = 0;\n    int aIndex = 0;\n    int bIndex = 0;\n        \n    if(a[0].equals(b[0])) {\n        count++;\n        aIndex++;\n        bIndex++;\n    } else if(a[0].compareTo(b[0]) < 0) {\n        aIndex++;\n    } else {\n        bIndex++;\n    }\n                                      \n    while(aIndex < a.length && bIndex < b.length) {\n        if(aIndex > 0 && a[aIndex-1].equals(a[aIndex])) {\n            aIndex++;\n        } else if(a[aIndex].equals(b[bIndex])) {\n            count++;\n            aIndex++;\n            bIndex++;\n        } else if(a[aIndex].compareTo(b[bIndex]) < 0) {\n            aIndex++;\n        } else {\n            bIndex++;\n        }\n    }\n    \n    return count;\n}\n"}, "factorial": {"id": "p154669", "code": "/* Given n of 1 or more, return the factorial of n, which is \n * n * (n-1) * (n-2) ... 1. Compute the result recursively (without loops).\n */\npublic int factorial(int n) {\n    if(n == 1)\n        return 1;\n          \n    return n * factorial(n - 1);\n}\n"}, "bunnyEars": {"id": "p183649", "code": "/* We have a number of bunnies and each bunny has two big floppy ears. We \n * want to compute the total number of ears across all the bunnies recursively \n * (without loops or multiplication).\n */\npublic int bunnyEars(int bunnies) {\n    if(bunnies == 0)\n        return 0;\n          \n    return 2 + bunnyEars(bunnies - 1);\n}\n"}, "fibonacci": {"id": "p120015", "code": "/* The fibonacci sequence is a famous bit of mathematics, and it happens to \n * have a recursive definition. The first two values in the sequence are \n * 0 and 1 (essentially 2 base cases). Each subsequent value is the sum of the \n * previous two values, so the whole sequence is: 0, 1, 1, 2, 3, 5, 8, 13, 21 \n * and so on. Define a recursive fibonacci(n) method that returns the nth \n * fibonacci number, with n=0 representing the start of the sequence.\n */\npublic int fibonacci(int n) {\n    if(n <= 1)\n        return n;\n          \n    return fibonacci(n-1) + fibonacci(n-2);\n}\n"}, "bunnyEars2": {"id": "p107330", "code": "/* We have bunnies standing in a line, numbered 1, 2, ... The odd bunnies \n * (1, 3, ..) have the normal 2 ears. The even bunnies (2, 4, ..) we'll say \n * have 3 ears, because they each have a raised foot. Recursively return the \n * number of \"ears\" in the bunny line 1, 2, ... n (without loops or \n * multiplication).\n */\npublic int bunnyEars2(int bunnies) {\n    if(bunnies == 0)\n        return 0;\n          \n    if(bunnies % 2 == 1)\n        return 2 + bunnyEars2(bunnies-1);\n                    \n    return 3 + bunnyEars2(bunnies-1);\n}\n"}, "triangle": {"id": "p194781", "code": "/* We have triangle made of blocks. The topmost row has 1 block, the next row \n * down has 2 blocks, the next row has 3 blocks, and so on. Compute \n * recursively (no loops or multiplication) the total number of blocks in such \n * a triangle with the given number of rows.\n */\npublic int triangle(int rows) {\n    if(rows == 0)\n        return 0;\n          \n    return rows + triangle(rows-1);\n}\n"}, "count7": {"id": "p101409", "code": "/* Given a non-negative int n, return the count of the occurrences of 7 as a \n * digit, so for example 717 yields 2. (no loops).\n */\npublic int count7(int n) {\n    if(n == 0)\n        return 0;\n          \n    if(n % 10 == 7)\n        return 1 + count7(n / 10);\n                    \n    return count7(n / 10);\n}\n"}, "count8": {"id": "p192383", "code": "/* Given a non-negative int n, compute recursively (no loops) the count of \n * the occurrences of 8 as a digit, except that an 8 with another 8 \n * immediately to its left counts double, so 8818 yields 4.\n */\npublic int count8(int n) {\n    if(n == 0)\n        return 0;\n          \n    if(n % 10 == 8) {\n        if((n / 10) % 10 == 8)\n            return 2 + count8(n/10);\n                            \n        return 1 + count8(n/10);\n    }\n                                    \n    return count8(n/10);\n}\n"}, "powerN": {"id": "p158888", "code": "/* Given base and n that are both 1 or more, compute recursively (no loops) \n * the value of base to the n power, so powerN(3, 2) is 9 (3 squared).\n */\npublic int powerN(int base, int n) {\n    if(n <= 1)\n        return base;\n          \n    return base * powerN(base, n - 1);\n}\n"}, "countX": {"id": "p170371", "code": "/* Given a string, compute recursively (no loops) the number of lowercase 'x' \n * chars in the string.\n */\npublic int countX(String str) {\n    if(str.length() == 0)\n        return 0;\n          \n    if(str.charAt(0) == 'x')\n        return 1 + countX(str.substring(1));\n                    \n    return countX(str.substring(1));\n}\n"}, "changeXY": {"id": "p101372", "code": "/* Given a string, compute recursively (no loops) a new string where all the \n * lowercase 'x' chars have been changed to 'y' chars.\n */\npublic String changeXY(String str) {\n    if(str.length() == 0)\n        return str;\n          \n    if(str.charAt(0) == 'x')\n        return 'y' + changeXY(str.substring(1));\n                    \n    return str.charAt(0) + changeXY(str.substring(1));\n}\n"}, "changePi": {"id": "p170924", "code": "/* Given a string, compute recursively (no loops) a new string where all \n * appearances of \"pi\" have been replaced by \"3.14\".\n */\npublic String changePi(String str) {\n    if(str.length() <= 1)\n        return str;\n          \n    if(str.substring(0, 2).equals(\"pi\"))\n        return \"3.14\" + changePi(str.substring(2));\n                    \n    return str.charAt(0) + changePi(str.substring(1));\n}\n"}, "noX": {"id": "p105967", "code": "/* Given a string, compute recursively a new string where all the 'x' chars \n * have been removed.\n */\npublic String noX(String str) {\n    if(str.length() == 0)\n        return str;\n          \n    if(str.charAt(0) == 'x')\n        return noX(str.substring(1));\n                    \n    return str.charAt(0) + noX(str.substring(1));\n}\n"}, "array6": {"id": "p108997", "code": "/* Given an array of ints, compute recursively if the array contains a 6. \n * We'll use the convention of considering only the part of the array that \n * begins at the given index. In this way, a recursive call can pass index+1 \n * to move down the array. The initial call will pass in index as 0.\n */\npublic boolean array6(int[] nums, int index) {\n    if(index >= nums.length)\n        return false;\n          \n    return nums[index] == 6 || array6(nums, index + 1);\n}\n"}, "array11": {"id": "p135988", "code": "/* Given an array of ints, compute recursively the number of times that the \n * value 11 appears in the array. We'll use the convention of considering only \n * the part of the array that begins at the given index. In this way, a \n * recursive call can pass index+1 to move down the array. The initial call \n * will pass in index as 0.\n */\npublic int array11(int[] nums, int index) {\n    if(index >= nums.length)\n        return 0;\n          \n    if(nums[index] == 11)\n        return 1 + array11(nums, index + 1);\n                    \n    return array11(nums, index + 1);\n}\n"}, "array220": {"id": "p173469", "code": "/* Given an array of ints, compute recursively if the array contains somewhere \n * a value followed in the array by that value times 10. We'll use the \n * convention of considering only the part of the array that begins at the \n * given index. In this way, a recursive call can pass index+1 to move down \n * the array. The initial call will pass in index as 0.\n */\npublic boolean array220(int[] nums, int index) {\n    if(index >= nums.length - 1)\n        return false;\n          \n    return nums[index+1] == 10 * nums[index] || array220(nums, index + 1);\n}\n"}, "allStar": {"id": "p183394", "code": "/* Given a string, compute recursively a new string where all the adjacent \n * chars are now separated by a \"*\".\n */\npublic String allStar(String str) {\n    if(str.length() <= 1)\n        return str;\n          \n    return str.charAt(0) + \"*\" + allStar(str.substring(1));\n}\n"}, "pairStar": {"id": "p158175", "code": "/* Given a string, compute recursively a new string where identical chars \n * that are adjacent in the original string are separated from each other by \n * a \"*\".\n */\npublic String pairStar(String str) {\n    if(str.length() <= 1)\n        return str;\n          \n    if(str.charAt(0) == str.charAt(1))\n        return str.charAt(0) + \"*\" + pairStar(str.substring(1));\n                    \n    return str.charAt(0) + pairStar(str.substring(1));\n}\n"}, "endX": {"id": "p105722", "code": "/* Given a string, compute recursively a new string where all the lowercase \n * 'x' chars have been moved to the end of the string.\n */\npublic String endX(String str) {\n    if(str.length() <= 1)\n        return str;\n          \n    if(str.charAt(0) == 'x')\n        return endX(str.substring(1)) + 'x';\n                    \n    return str.charAt(0) + endX(str.substring(1));\n}\n"}, "countPairs": {"id": "p154048", "code": "/* We'll say that a \"pair\" in a string is two instances of a char separated by \n * a char. So \"AxA\" the A's make a pair. Pair's can overlap, so \"AxAxA\" \n * contains 3 pairs -- 2 for A and 1 for x. Recursively compute the number of \n * pairs in the given string.\n */\npublic int countPairs(String str) {\n    if(str.length() <= 2)\n        return 0;\n          \n    if(str.charAt(0) == str.charAt(2))\n        return 1 + countPairs(str.substring(1));\n                    \n    return countPairs(str.substring(1));\n}\n"}, "countAbc": {"id": "p161124", "code": "/* Count recursively the total number of \"abc\" and \"aba\" substrings that \n * appear in the given string.\n */\npublic int countAbc(String str) {\n    if(str.length() <= 2)\n        return 0;\n          \n    if(str.substring(0, 3).equals(\"abc\") || str.substring(0, 3).equals(\"aba\"))\n        return 1 + countAbc(str.substring(2));\n                    \n    return countAbc(str.substring(1));\n}\n"}, "count11": {"id": "p167015", "code": "/* Given a string, compute recursively (no loops) the number of \"11\" \n * substrings in the string. The \"11\" substrings should not overlap.\n */\npublic int count11(String str) {\n    if(str.length() <= 1)\n        return 0;\n          \n    if(str.substring(0, 2).equals(\"11\"))\n        return 1 + count11(str.substring(2));\n                    \n    return count11(str.substring(1));\n}\n"}, "stringClean": {"id": "p104029", "code": "/* Given a string, return recursively a \"cleaned\" string where adjacent chars \n * that are the same have been reduced to a single char. So \"yyzzza\" yields \n * \"yza\".\n */\npublic String stringClean(String str) {\n    if(str.length() <= 1)\n        return str;\n          \n    if(str.charAt(0) == str.charAt(1))\n        return stringClean(str.substring(1));\n                    \n    return str.charAt(0) + stringClean(str.substring(1));\n}\n"}, "countHi2": {"id": "p143900", "code": "/* Given a string, compute recursively the number of times lowercase \"hi\" \n * appears in the string, however do not count \"hi\" that have an 'x' \n * immedately before them.\n */\npublic int countHi2(String str) {\n    if(str.length() <= 1)\n        return 0;\n          \n    if(str.length() > 2 && str.substring(0, 3).equals(\"xhi\"))\n        return countHi2(str.substring(3));\n                    \n    if(str.substring(0, 2).equals(\"hi\"))\n        return 1 + countHi2(str.substring(2));\n                            \n    return countHi2(str.substring(1));\n}\n"}, "parenBit": {"id": "p137918", "code": "/* Given a string that contains a single pair of parenthesis, compute \n * recursively a new string made of only of the parenthesis and their \n * contents, so \"xyz(abc)123\" yields \"(abc)\".\n */\npublic String parenBit(String str) {\n    if(str.charAt(0) == '(' && str.charAt(str.length()-1) == ')')\n        return str;\n          \n    if(str.charAt(0) == '(')\n        return parenBit(str.substring(0, str.length() - 1));\n                    \n    if(str.charAt(str.length() - 1) == ')')\n        return parenBit(str.substring(1));\n                              \n    return parenBit(str.substring(1, str.length() - 1));\n}\n"}, "nestParen": {"id": "p183174", "code": "/* Given a string, return true if it is a nesting of zero or more pairs of \n * parenthesis, like \"(())\" or \"((()))\".\n */\npublic boolean nestParen(String str) {\n    if(str.length() == 0)\n        return true;\n          \n    if(str.charAt(0) == '(' && str.charAt(str.length()-1) == ')')\n        return nestParen(str.substring(1, str.length()-1));\n                    \n    return false;\n}\n"}, "strCount": {"id": "p186177", "code": "/* Given a string and a non-empty substring sub, compute recursively the \n * number of times that sub appears in the string, without the sub strings \n * overlapping.\n */\npublic int strCount(String str, String sub) {\n    if(str.length() < sub.length())\n        return 0;\n          \n    if(str.substring(0, sub.length()).equals(sub))\n        return 1 + strCount(str.substring(sub.length()), sub);\n                    \n    return strCount(str.substring(1), sub);\n}\n"}, "strCopies": {"id": "p118182", "code": "/* Given a string and a non-empty substring sub, compute recursively if at \n * least n copies of sub appear in the string somewhere, possibly with \n * overlapping. N will be non-negative.\n */\npublic boolean strCopies(String str, String sub, int n) {\n    if(n == 0)\n        return true;\n          \n    if(str.length() < sub.length())\n        return false;\n                  \n    if(str.substring(0, sub.length()).equals(sub))\n        return strCopies(str.substring(1), sub, n-1);\n                            \n    return strCopies(str.substring(1), sub, n);\n}\n"}, "strDist": {"id": "p195413", "code": "/* Given a string and a non-empty substring sub, compute recursively the \n * largest substring which starts and ends with sub and return its length.\n */\npublic int strDist(String str, String sub) {\n    if(str.length() < sub.length())\n        return 0;\n          \n    if(str.substring(0, sub.length()).equals(sub) &&\n        str.substring(str.length() - sub.length()).equals(sub))\n        return str.length();\n                        \n    if(!str.substring(0, sub.length()).equals(sub))\n        return strDist(str.substring(1), sub);\n                                  \n    return strDist(str.substring(0, str.length()-1), sub);\n}\n"}, "groupSum": {"id": "p145416", "code": "/* Given an array of ints, is it possible to choose a group of some of the \n * ints, such that the group sums to the given target? This is a classic \n * backtracking recursion problem. Rather than looking at the whole array, \n * our convention is to consider the part of the array starting at index \n * start and continuing to the end of the array. The caller can specify the \n * whole array simply by passing start as 0. No loops are needed -- the \n * recursive calls progress down the array.\n */\npublic boolean groupSum(int start, int[] nums, int target) {\n    if(start >= nums.length)\n        return target == 0;\n          \n    if(groupSum(start+1, nums, target - nums[start]))\n        return true;\n                    \n    if(groupSum(start+1, nums, target))\n        return true;\n                              \n    return false;\n}\n"}, "groupSum6": {"id": "p199368", "code": "/* Given an array of ints, is it possible to choose a group of some of the \n * ints, beginning at the start index, such that the group sums to the given \n * target? However, with the additional constraint that all 6's must be \n * chosen. (No loops needed.)\n */\npublic boolean groupSum6(int start, int[] nums, int target) {\n    if(start >= nums.length)\n        return target == 0;\n          \n    if(nums[start] == 6)\n        return groupSum6(start+1, nums, target - 6);\n                    \n    if(groupSum6(start+1, nums, target - nums[start]))\n        return true;\n                              \n    if(groupSum6(start+1, nums, target))\n        return true;\n                                        \n    return false;\n}\n"}, "groupNoAdj": {"id": "p169605", "code": "/* Given an array of ints, is it possible to choose a group of some of the \n * ints, such that the group sums to the given target with this additional \n * constraint: If a value in the array is chosen to be in the group, the \n * value immediately following it in the array must not be chosen. (No loops \n * needed.)\n */\npublic boolean groupNoAdj(int start, int[] nums, int target) {\n    if(start >= nums.length)\n        return target == 0;\n          \n    if(groupNoAdj(start+2, nums, target - nums[start]))\n        return true;\n                    \n    if(groupNoAdj(start+1, nums, target))\n        return true;\n                              \n    return false;\n}\n"}, "groupSum5": {"id": "p138907", "code": "/* Given an array of ints, is it possible to choose a group of some of the \n * ints, such that the group sums to the given target with these additional \n * constraints: all multiples of 5 in the array must be included in the group. \n * If the value immediately following a multiple of 5 is 1, it must not be \n * chosen. (No loops needed.)\n */\npublic boolean groupSum5(int start, int[] nums, int target) {\n    if(start >= nums.length)\n        return target == 0;\n          \n    if(nums[start] % 5 == 0) {\n        if(start <= nums.length - 2 && nums[start+1] == 1)\n            return groupSum5(start+2, nums, target - nums[start]);\n                            \n        return groupSum5(start+1, nums, target - nums[start]);\n    }\n                                    \n    if(groupSum5(start+1, nums, target - nums[start]))\n        return true;\n                                              \n    if(groupSum5(start+1, nums, target))\n        return true;\n                                                        \n    return false;\n}\n"}, "groupSumClump": {"id": "p105136", "code": "/* Given an array of ints, is it possible to choose a group of some of the \n * ints, such that the group sums to the given target, with this additional \n * constraint: if there are numbers in the array that are adjacent and the \n * identical value, they must either all be chosen, or none of them chosen. \n * For example, with the array {1, 2, 2, 2, 5, 2}, either all three 2's in the \n * middle must be chosen or not, all as a group. (one loop can be used to \n * find the extent of the identical values).\n */\npublic boolean groupSumClump(int start, int[] nums, int target) {\n    if(start >= nums.length)\n        return target == 0;\n          \n    int i = start;\n    int sum = 0;\n    \n    while(i < nums.length && nums[start] == nums[i]) {\n        sum += nums[i];\n        i++;\n    }\n                              \n    if(groupSumClump(i, nums, target - sum))\n        return true;\n                                        \n    if(groupSumClump(i, nums, target))\n        return true;\n                                                  \n    return false;\n}\n"}, "splitArray": {"id": "p185204", "code": "/* Given an array of ints, is it possible to divide the ints into two groups, \n * so that the sums of the two groups are the same. Every int must be in one \n * group or the other. Write a recursive helper method that takes whatever \n * arguments you like, and make the initial call to your recursive helper \n * from splitArray(). (No loops needed.)\n */\npublic boolean splitArray(int[] nums) {\n    return splitArrayHelper(0, nums, 0, 0);\n}\n\npublic boolean splitArrayHelper(int start, int[] nums, int group1, \n    int group2) {\n    if(start >= nums.length)\n        return group1 == group2;\n            \n    if(splitArrayHelper(start+1, nums, group1 + nums[start], group2))\n        return true;\n                      \n    if(splitArrayHelper(start+1, nums, group1, group2 + nums[start]))\n        return true;\n                                \n    return false;\n}\n"}, "splitOdd10": {"id": "p171660", "code": "/* Given an array of ints, is it possible to divide the ints into two groups, \n * so that the sum of one group is a multiple of 10, and the sum of the other \n * group is odd. Every int must be in one group or the other. Write a \n * recursive helper method that takes whatever arguments you like, and make \n * the initial call to your recursive helper from splitOdd10(). (No loops \n * needed.)\n */\npublic boolean splitOdd10(int[] nums) {\n    return splitOdd10Helper(0, nums, 0, 0);\n}\n\npublic boolean splitOdd10Helper(int start, int[] nums, int mult, int odd) {\n    if(start >= nums.length)\n        return mult % 10 == 0 && odd % 2 == 1;\n            \n    if(splitOdd10Helper(start+1, nums, mult + nums[start], odd))\n        return true;\n                      \n    if(splitOdd10Helper(start+1, nums, mult, odd + nums[start]))\n        return true;\n                                \n    return false;\n}\n"}, "split53": {"id": "p168295", "code": "/* Given an array of ints, is it possible to divide the ints into two groups, \n * so that the sum of the two groups is the same, with these constraints: all \n * the values that are multiple of 5 must be in one group, and all the values \n * that are a multiple of 3 (and not a multiple of 5) must be in the other. \n * (No loops needed.)\n */\npublic boolean split53(int[] nums) {\n    return split53Helper(0, nums, 0, 0);\n}\n\npublic boolean split53Helper(int start, int[] nums, int mult5, int mult3) {\n    if(start >= nums.length)\n        return mult5 == mult3;\n            \n    if(nums[start] % 5 == 0)\n        return split53Helper(start+1, nums, mult5 + nums[start], mult3);\n                      \n    if(nums[start] % 3 == 0)\n        return split53Helper(start+1, nums, mult5, mult3 + nums[start]);\n                                \n    if(split53Helper(start+1, nums, mult5 + nums[start], mult3))\n        return true;\n                                          \n    if(split53Helper(start+1, nums, mult5, mult3 + nums[start]))\n        return true;\n                                                    \n    return false;\n}\n"}, "mapBully": {"id": "p197888"}, "mapShare": {"id": "p148813"}, "mapAB": {"id": "p107259"}, "topping1": {"id": "p182712"}, "topping2": {"id": "p196458"}, "topping3": {"id": "p128461"}, "mapAB2": {"id": "p115011"}, "mapAB3": {"id": "p115012"}, "mapAB4": {"id": "p136950"}, "word0": {"id": "p152303"}, "wordLen": {"id": "p125327"}, "pairs": {"id": "p126332"}, "wordCount": {"id": "p117630"}, "firstChar": {"id": "p168493"}, "wordAppend": {"id": "p103593"}, "wordMultiple": {"id": "p190862"}, "allSwap": {"id": "p134133"}, "firstSwap": {"id": "p150113"}, "doubling": {"id": "p117665"}, "square": {"id": "p139586"}, "addStar": {"id": "p170181"}, "copies3": {"id": "p181634"}, "moreY": {"id": "p177528"}, "math1": {"id": "p103869"}, "rightDigit": {"id": "p152194"}, "lower": {"id": "p186894"}, "noNeg": {"id": "p103456"}, "no9": {"id": "p124510"}, "noTeen": {"id": "p137274"}, "noZ": {"id": "p105671"}, "noLong": {"id": "p194496"}, "no34": {"id": "p184496"}, "noYY": {"id": "p115967"}, "two2": {"id": "p148198"}, "square56": {"id": "p132748"}}